		/********************************************************************\
		***                      NON-DOMINATED SORTING                     ***
		***                             using                              ***
		***                       GENETIC ALGORITHM                        ***
		***                              for                               ***
		***                  MULTI OBJECTIVE OPTIMIZATION                  ***
		***                                                                ***
		***        Developed by : Kalyanmoy Deb and Mayank Goyal           ***
		***           The Department of Mechanical Engineering             ***
		***            Indian Institute of Technology, Kanpur              ***
		***                  Kanpur, PIN 208 016, INDIA                    ***
		***................................................................***
		*** This is a GA implementation for multi-objective optimization.  ***
		*** For multi-objective optimization, non-domonated sorting has    ***
		*** been used.  The design variables can be Binary, Integer, Real  ***
		*** or Enumerated data type.  Moreover a design vector can have    ***
		*** design variables where each variable can be any of the above   ***
		*** mentioned types.  The order in which the design variables      ***
		*** are needed is also maintained in the code.  For multi-objective***
		*** optimization, sharing is done using either of two ways :       ***
		*** Sharing on Fitness Space or Sharing on Parameter Space. After  ***
		*** completion, results are stored in a 'result.out' and for       ***
		*** detailed inspection in a file 'report'. For a detail discussion***
		*** please refer to Journal paper:                                 ***
		*** Srinivas, N. and Deb, K. (1994). Multiobjective optimization   ***
		***  using nondominated sorting genetic algorithms. Evolutionary   ***
		***  Computation. Vol. 2, No. 3. Pages 221--248.                   ***
		***                                                                ***
		*** Please send your comments or bug information at                ***
		*** deb@ls11.informatik.uni-dortmund.de or deb@iitk.ernet.in       ***
		***                                                                ***
		*** All rights reserved. Not to be used for commercial purposes.   ***
		*** In case of a publication resulted by use of this code,         ***
		*** an acknowledgement will be appreciated.                        ***
		***                                                                ***
		*** Last update 15 June 1998       Kalyanmoy Deb                   ***
		\********************************************************************/

#include<stdio.h>
#include<math.h>
#include <time.h>

#define BITS_PER_BYTE 8
#define UINTSIZE     31// (BITS_PER_BYTE*sizeof(unsigned))
#define INFINITY      1e7
#define EPSILON       1e-6
#define PI            3.1415927
#define MAXVECSIZE    30
#define MAXPOPSIZE    100000
#define MAXENUMDATA   100
#define MAXOBJ        5
#define MINSCHEME     1		/* do not change */
#define TRUE          1		/*     ,,        */
#define FALSE         0		/*     ,,        */
#define ONESITE       1		/*     ,,        */
#define UNIF          2		/*     ,,        */
#define BIN           1		/*     ,,        */
#define INT           2		/*     ,,        */
#define ENUM          3		/*     ,,        */
#define CONT          4		/*     ,,        */
#define square(x)  ((x)*(x))
#define cube(x)  ((x)*(x)*(x))
#define PENALTY_COEFF 1.0e3

		/*=============================
		  Choose your problem here (put your problem at the end of code)
		  ===========================*/
#define book

		/*=================
		  TYPE DEFINTIONS :
		  =================*/
struct indiv
{
  unsigned  *chrom;		/* chrosome string      */
  float fitness[MAXOBJ];	/* fitness functions    */
 long double x[MAXVECSIZE];		/* variables            */
  float dumfitness;		/* modified objective   */
  int flag;			/* flag as follows
				   0 => untouched
				   1 => dominated
				   2 => non-dominated
				   3 => exhausted   */
  int front;			/* Front of the indiv.  */
  int parent1;			/* two parents */
  int parent2;
};
typedef struct indiv INDIVIDUAL;
typedef INDIVIDUAL *POPULATION;	/* array of individuals */

		/*====================
		  FUNCTION PROTOTYPES :
		  ====================*/
float randomperc ();
float get_beta ();
float get_delta ();
float get_beta_rigid ();
double noise ();
float rndreal ();
int small (float);

int isConnected();

void traverse(int u, int visited[]);
double DISTANCE_ (int i, int j, int k, int l);
		/*==================
		  GLOBAL VARIABLES  :
		  ==================*/
int pop_size,			/* Population Size               */
  gen_no,			/* Current generation number     */
  max_gen,			/* Maximum no. of generations    */
  no_xover,			/* No. of cross overs done       */
  no_mutation,			/* No. of mutations done         */
  num_var,			/* Number of total design variables */
  num_bin_var,			/* Number of binary variables    */
  num_int_var,			/* Number of integer variables   */
  num_enum_var,			/* Number of enumerated variables */
  num_cont_var,			/* Number of continuous variables */
  num_obj,			/* Number of objectives           */
  lchrom[MAXVECSIZE],		/* Length of chromosome               */
  chromsize,			/* Number of bytes needed to store
				   lchrom strings */
  x_strategy,			/* Crossover strategy UNIF,ONESITE etc. */
  REPORT,			/* Flag for Full reports (True/False) */
  var_RIGID[MAXVECSIZE],	/* Flag for rigid boundaries (T/F) */
  BINGA,			/* Flag for binary GA (T/F)     */
  REALGA,			/* Flag for real-GA (T/F)         */
  FITNESS,			/* Flag for sharing strategy (T/F)  */
  PARAM, minmax[MAXOBJ],	/* min or max flag */
  tourneylist[MAXPOPSIZE],	/* List of indices of individuals for
				   tournament selection routine */
  tourneypos,			/* Current position of tournament   */
  tourneysize,			/* Tournament size ( = 2 for binary ) */
  var_type[MAXVECSIZE],		/* Temp. variable type            */
  TotalChromLength,		/* Total Chromosome Length       */
  num_enum_data[MAXVECSIZE];	/* Number of Enumerated Data for
				   each enumerated variable    */

float seed,			/* Random seed number           */
  n_distribution_c, n_distribution_m,	/* Distribution
					   index for SBX    */
  p_xover,			/* Cross over probability       */
  p_mutation,			/* Mutation probability         */
  closeness,			/* Closeness epsilon            */
  minx[MAXVECSIZE],		/* Minimum value of design variables */
  maxx[MAXVECSIZE],		/* Maximum value of design variables */
  // x_lower[MAXVECSIZE],		/* Lower and Upper bounds on each  */
  // x_upper[MAXVECSIZE],		/*        design variable          */
  afmin[MAXOBJ],		/* approx min value of obj funs. */
  afmax[MAXOBJ],		/* approx max value of obj funs  */
  dshare,			/* Sharing distance                */
  max_spread,			/* Maximum spread */
  maxf[MAXOBJ],			/* Maximum fitness values         */
  minf[MAXOBJ],			/* Minimum fitness values         */
  avgfitness[MAXOBJ],		/* Average fitness values         */
  dum_avg, min_dum,		/* Avg. and min. dummy fitness      */
  init_dum, delta_dum,		/* Initial and delta dummy fitness  */
  c1 = 0.0, c2 = 0.0,		/* Children                         */
  weightage[MAXOBJ],		/* Weightage assigned to fitness    */
  EnumData[MAXVECSIZE][MAXENUMDATA];	/* Enumerated Data       */

long double  x_lower[MAXVECSIZE],		/* Lower and Upper bounds on each  */
  x_upper[MAXVECSIZE];		/*        design variable          */

POPULATION oldpop, newpop;	/* Old and New populations   */

int *choices, nremain;
float *fraction;

		//     NSGA VARIAbBLES

int largeur = 20, longeur = 35;	// les dimentions de building: m,n
int dL = 1, dl = 1;		// les distances horsontale et verticale (respectivement) entre les capteurss.
double Rs = 4, Rc=10;			// the sensor rang
float PL0=40.2;
float power_trans=-11;
float power_recev= -70;
double SEUIL_COUVERTURE, SEUIL_CONNECTIVITE;
int TAILLE_CHROMOSOME;
int sensor[100][100];		// matrice represente le deploiment des sensors
float fitness1[100000], fitness2[100000];
int position_capt[3000];
int NUM_SENSORS;
double COUVRAGE;
int taille_pc ,TAILLE_PC;
int graph[1000][1000];
int NUM_CAPTEUR_INI;
int Distan_entr_cap_ini = 6;
int contrainte_connectivite = 2;


float weight1 =0.5, weight2 = 0.5, afmin_1 = 33, afmax_1 = 37, afmin_2 = 100, afmax_2 = 100;
int POP_SIZE=10;
float P_MUTATION=1,P_XOVER=1;
int MAX_GENERATION=5;
int INITIAL_CAP=4; // rarement modifié .(on l'ajoute à les chromosomes au debut)  =2 (si 10*12)
int NUM_PUT_CAP=1;  // le nombre des capteurs ajoutés lorsque le nombre des capteur et petit.
int MAX_CAPTEUR=40;   // generalement est le plafond de capteur
char STRATEGY='f';
int NUM_MUT_BIT=30; // le nombre de bit changés.
double long X_UPPER = 5260135901548373507240989882880128665550339802823173859498280903068732154297080822113666536277588451226982968856178217713019432250183803863127814770651880849955223671128444598191663757884322717271293251735781375;
//5260135901548373507240989882880128665550339802823173859498280903068732154297080822113666536277588451226982968856178217713019432250183803863127814770651880849955223671128444598191663757884322717271293251735781375
//1329227995784915872903807060280344575

// utilisables pour l'afichage:
double MAX_COUV_1 = -1, MAX_COUV_2 = -1, MAX_COUV_3 = -1, MAX_COUV_4 =
  -1, MAX_COUV_5 = -1, MAX_COUV_6 = -1, MAX_COUV_7 = -1, MAX_COUV_8 =
  -1, MAX_COUV_9 = -1, MAX_COUV_10 = -1, MAX_COUV_11 = -1, MAX_COUV_12 =
  -1, MAX_COUV_13 = -1, MAX_COUV_14 = -1, MAX_COUV_15 = -1, MAX_COUV_16 =
  -1, MAX_COUV_17 = -1, MAX_COUV_18 = -1, MAX_COUV_19 = -1, MAX_COUV_20 =
  -1, MAX_COUV_21 = -1, MAX_COUV_22 = -1, MAX_COUV_23 = -1, MAX_COUV_24 =
  -1, MAX_COUV_25 = -1, MAX_COUV_26 = -1, MAX_COUV_27 = -1, MAX_COUV_28 =
    -1, MAX_COUV_29 = -1, MAX_COUV_30 = -1, MAX_COUV_31 = -1, MAX_COUV_32 =
  -1, MAX_COUV_33 = -1, MAX_COUV_34 = -1, MAX_COUV_35 = -1, MAX_COUV_36 =
  -1, MAX_COUV_37 = -1, MAX_COUV_38 = -1, MAX_COUV_39 = -1, MAX_COUV_40 =
  -1, MAX_COUV_41 = -1, MAX_COUV_42 = -1, MAX_COUV_43 = -1, MAX_COUV_44 =
  -1, MAX_COUV_45 = -1, MAX_COUV_46 = -1, MAX_COUV_47 = -1, MAX_COUV_48 =
  -1, MAX_COUV_49 = -1, MAX_COUV_50 = -1, MAX_COUV_51 = -1, MAX_COUV_52 =-1;
  /*
/////////////// B1 //////////////////
float obstacles_horis[100][100] = {
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

float obstacles_verti[100][100] = {
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};


float obstacles_horis_sig[100][100] = {
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

float obstacles_verti_sig[100][100] = {
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};
*/

/*
		/////////////////////// B2 //////////////////////////
		   float obstacles_horis[1000][1000]=
		   {
		   {1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
		   {1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
		   {1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
		   {1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
		   };
		   float obstacles_verti[1000][1000]=
		   {
		   {1.28,0,0,0,1.28,0,0,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,0,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,0,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,0,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,0,0,0,0,0,0,0,0,1.28},
		   {1.28,0,0,0,0,0,0,0,0,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,0,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,0,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,0,0,1.28,0,0,0,1.28},
		   {1.28,0,0,0,1.28,0,0,0,1.28,0,0,0,1.28},
		   };


		   float obstacles_horis_sig[1000][1000]=
		   {
		   {3,0,0,0,3,0,3,0,0,0,3},
		   {3,0,0,0,3,0,3,0,0,0,3},
		   {3,0,0,0,2,0,2,0,0,0,3},
		   {3,0,0,0,2,0,2,0,0,0,3},
		   {3,0,0,0,3,0,3,0,0,0,3},
		   {3,0,0,0,3,0,3,0,0,0,3},
		   {3,0,0,0,2,0,2,0,0,0,3},
		   {3,0,0,0,2,0,2,0,0,0,3},
		   {3,0,0,0,3,0,3,0,0,0,3},
		   {3,0,0,0,3,0,3,0,0,0,3},
		   {3,0,0,0,2,0,2,0,0,0,3},
		   {3,0,0,0,2,0,2,0,0,0,3},
		   };
		   float obstacles_verti_sig[1000][1000]=
		   {
		   {3,0,0,0,3,0,0,0,3,0,0,0,3},
		   {3,0,0,0,3,0,0,0,3,0,0,0,3},
		   {3,0,0,0,3,0,0,0,3,0,0,0,3},
		   {3,0,0,0,3,0,0,0,3,0,0,0,3},
		   {3,0,0,0,0,0,0,0,0,0,0,0,3},
		   {3,0,0,0,0,0,0,0,0,0,0,0,3},
		   {3,0,0,0,3,0,0,0,3,0,0,0,3},
		   {3,0,0,0,3,0,0,0,3,0,0,0,3},
		   {3,0,0,0,3,0,0,0,3,0,0,0,3},
		   {3,0,0,0,3,0,0,0,3,0,0,0,3},
		   };



*/
  /*

///////////////////////////// B3 ////////////////////////

float obstacles_horis[1000][1000]=
{
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}

};
float obstacles_verti[1000][1000]=
{
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};


float obstacles_horis_sig[1000][1000]=
{
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}

};
float obstacles_verti_sig[1000][1000]=
{
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
*/




 ///////////////////////////// B4 /////////////////
float obstacles_horis[1000][1000]=
                     	{
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,1.28,0,1.28,0,0,0,1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},

                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,1.28,0,1.28,0,0,0,1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},

                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,1.28,0,1.28,0,0,0,1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},

                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},

                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,1.28,0,1.28,0,0,0,1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},

                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,1.28,0,1.28,0,0,0,1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},

                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,0.43,0,0.43,0,0,0,1.28,0,0,0,0.43,0,0.43,0,0,0,1.28},
                     	{1.28,0,0,0,1.28,0,1.28,0,0,0,1.28,0,0,0,1.28,0,1.28,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},
                     	{1.28,0,0,0,0.46,0,0.46,0,0,0,1.28,0,0,0,0.46,0,0.46,0,0,0,1.28},

                     	};
                     	float obstacles_verti[1000][1000]=
                     	{
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},

                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.46,0,0,0,0,0.46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.46,0,0,0,0,0.46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},

                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},

                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},

                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.46,0,0,0,0,0.46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.46,0,0,0,0,0.46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.28},

                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28},
                     	{1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28,0,0,0,0,1.28}
                     	};

                     	float obstacles_horis_sig[1000][1000]=
                     	{
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,3,0,3,0,0,0,3,0,0,0,3,0,3,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},

                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,3,0,3,0,0,0,3,0,0,0,3,0,3,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},

                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,3,0,3,0,0,0,3,0,0,0,3,0,3,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},

                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},

                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,3,0,3,0,0,0,3,0,0,0,3,0,3,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},

                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,3,0,3,0,0,0,3,0,0,0,3,0,3,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},

                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,3,0,3,0,0,0,3,0,0,0,3,0,3,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},
                     	{3,0,0,0,2,0,2,0,0,0,3,0,0,0,2,0,2,0,0,0,3},

                     	};
                     	float obstacles_verti_sig[1000][1000]=
                     	{
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},

                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},

                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},

                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},

                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
                     	{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},

                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3},
                     	{3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,3}
                     	};












int Min_sensor = 1000, gen_Min_sensor = -1000;

		/*====================================================================
		  SUBROUTINE FOR INPUTTING GLOBAL PARAMETERS :
		  ====================================================================*/
float
Flou_ran (float maxval)
{

  float ran = (float) (rand () % 100) / ((100 / maxval) + 0.1);
  return ran;

}

input_parameters ()
{
  int k, temp2, count;
  char ans;
  float temp1, sumweight;

  //printf("\nNumber of objective functions (2) --> ");
  // scanf("%d",&num_obj);                          //----------------------------------------------->
  num_obj = 2;
  minmax[0] = 1;
  minmax[1] = -1;
  /*
     printf("\nSpecify minimization (1) or maximization (-1) for each function ");
     for (count=0; count<num_obj; count++)
     {
     printf("\n  Objective function #%2d (1 or -1)      --> ",count+1);
     scanf("%d",&minmax[count]);
     }
   */

  //printf("\nNumber of variables (Maximum %2d) --- : ",MAXVECSIZE); //---------------------------------->>
  //scanf("%d",&num_var);
  num_var = 1;


  BINGA = FALSE;
  REALGA = FALSE;
  TotalChromLength = 0;

  num_bin_var = 0;
  num_int_var = 0;
  num_enum_var = 0;
  num_cont_var = 0;
  for (k = 0; k <= num_var - 1; k++)
    {
      // printf("\nVariable Type for variable #%2d : \n",k+1);
      // printf("\t\t 1 for Binary\n");       //---------------------------------->>
      //printf("\t\t 2 for Integer\n");
      //printf("\t\t 3 for Enumerated\n");
      // printf("\t\t 4 for Continuous/Real");
      // printf("\n  Give your choice (1/2/3/4) ------- : ");
      var_type[k] = 1;
      //scanf("%d",&var_type[k]);
      //var_type[0]=1;
      if (var_type[k] != ENUM)	/* If not ENUM, ask for bounds */
	{
	  //printf("\nLower and Upper bounds of x[%d] ----- : ",k+1);

	  x_lower[k] = 0;	//Flou_ran(0.0);
	  x_upper[k] = X_UPPER;
	  //5260135901548373507240989882880128665550339802823173859498280903068732154297080822113666536277588451226982968856178217713019432250183803863127814770651880849955223671128444598191663757884322717271293251735781375;
	  //5260135901548373507240989882880128665550339802823173859498280903068732154297080822113666536277588451226982968856178217713019432250183803863127814770651880849955223671128444598191663757884322717271293251735781376
	  //5,260,135,901,548,373,507,240,989,882,880,128,665,550,339,802,823,173,859,498,280,903,068,732,154,297,080,822,113,666,536,277,588,451,226,982,968,856,178,217,713,019,432,250,183,803,863,127,814,770,651,880,849,955,223,671,128,444,598,191,663,757,884,322,717,271,293,251,735781376
	  //1329227995784915872903807060280344575
	  //printf ("\n%f", x_upper[k]);
	  //----------------------------------------------------------------------------------->>
	  //scanf("%f %f",&x_lower[k],&x_upper[k]);
	}

      if (var_type[k] != CONT)
	var_RIGID[k] = TRUE;

      if (var_type[k] == BIN)	/* If BIN Type ask for chromosome length */
	{
	  num_bin_var++;
	  BINGA = TRUE;
	  //printf("\nChromosome Length ------------------ : "); //---------------------------------->>
	  TAILLE_CHROMOSOME = taille_chrom ();
	  lchrom[k] = TAILLE_CHROMOSOME;
	  //printf("\nLa taille de chromosome est: %d \n",TAILLE_CHROMOSOME);
	  // scanf("%d",&lchrom[k]);
	  TotalChromLength += lchrom[k];
	}
      else
	lchrom[k] = 0;		/* End of BIN */

      if (var_type[k] == ENUM)	/* If ENUM Type read the enumerated data */
	{
	  num_enum_var++;
	  REALGA = TRUE;
	  printf ("\nEnter the data for variable [%d] in ASCENDING order.\n",
		  k + 1);
	  printf ("End of data recognized by 999999: ");
	  temp2 = 0;
	  scanf ("%f", &temp1);
	  EnumData[k][0] = temp1;
	  temp2++;
	  while (!small (temp1 - 999999.0))
	    {
	      scanf ("%f", &temp1);
	      EnumData[k][temp2] = temp1;
	      temp2++;
	    }
	  num_enum_data[k] = temp2 - 1;
	  x_lower[k] = EnumData[k][0];
	  x_upper[k] = EnumData[k][num_enum_data[k] - 1];
	}
      else
	num_enum_data[k] = 0;	/* End of ENUM */

      if (var_type[k] == INT)	/* If INT Type form the enumerated data */
	{
	  num_int_var++;
	  REALGA = TRUE;
	  num_enum_data[k] = x_upper[k] - x_lower[k] + 1;
	  for (count = 0; count < num_enum_data[k]; count++)
	    EnumData[k][count] = x_lower[k] + count;
	}			/* End of INT */

      if (var_type[k] == CONT)	/* If CONT Type */
	{
	  num_cont_var++;
	  REALGA = TRUE;
	  printf (" Are these bounds rigid ---- ? (y/n) : ");
	  do
	    {
	      ans = getchar ();
	    }
	  while (ans != 'y' && ans != 'n');
	  if (ans == 'y')
	    var_RIGID[k] = TRUE;
	  else
	    var_RIGID[k] = FALSE;
	}
    }				/* End of for loop for variable info. */
  printf ("\n");

  /*
     for (count=0; count<num_var; count++)
     {
     printf("Variable (#%2d) Type : ",count+1);
     switch (var_type[count])
     {
     case BIN  :
     printf("BINARY\n");
     break;
     case INT  :
     printf("INTEGER\n");
     break;
     case ENUM :
     printf("ENUMERATED\n");
     break;
     case CONT :
     printf("CONTINUOUS\n");
     break;
     }
     printf("Lower Bound   : %f\n",x_lower[count]);
     printf("Upper Bound   : %f\n",x_upper[count]);
     }
   */

  FITNESS = PARAM = FALSE;
  /*
     printf("\n Sharing Strategy :");
     printf("\n Sharing on Fitness Space   (f)");
     printf("\n Sharing on Parameter Space (p)");
     printf("\n Give your choice (f/p) p preferable : ");
   */






  do
    {
      //ans = getchar();           //----------------------------------------------------->
      ans = STRATEGY;
    }
  while (ans != 'f' && ans != 'p');
  if (ans == 'f')
    FITNESS = TRUE;
  else
    PARAM = TRUE;

  if (FITNESS)
    {
      //printf("\nEqual weightage for all objectives (y or n)?: ");
      do
	{
	  //  ans = getchar();    //------------------------------------------------------->
	  ans = 'n';
	}
      while (ans != 'y' && ans != 'n');
      if (ans == 'n')
	{


	  weightage[0] = weight1;
	  weightage[1] = weight2;
	  sumweight = weightage[0] + weightage[1];

	  afmin[0] = afmin_1;
	  afmax[0] = afmax_1;
	  afmin[1] = afmin_2;
	  afmax[1] = afmax_2;

	  printf ("\n%f   %f   %f   %f   %f   %f", weight1, weight2, afmin_1,
		  afmax_1, afmin_2, afmax_2);




	  /*
	     for (count = 0, sumweight = 0.0; count < num_obj; count++)
	     {
	     //-------------------------------------------------------------------------->
	     //printf("\n  Weight for objective #%2d (0.5) -> ",count+1);
	     //scanf("%f", &weightage[count]);
	     weightage[count] =0.5;// Flou_ran (0.5);
	     sumweight += weightage[count];
	     //----------------------------------------------------------------------------------------->
	     // printf("\n  Lower and Upper values of function #%2d (approx.) -> ",count+1);
	     //scanf("%f %f", &afmin[count], &afmax[count]);
	     afmin[count] = Flou_ran (5.0);
	     afmax[count] = Flou_ran (100.0);
	     }
	   */




	  for (count = 0; count < num_obj; count++)
	    weightage[count] /= sumweight;
	}
      else
	for (count = 0; count < num_obj; count++)
	  weightage[count] = 1.0 / (double) num_obj;
    }






  /* give a suggestion of dshare */// --------------------------------------------------->
  //printf("\nSigma share value accordingly (%8.3f) -- : ",0.5*pow(0.1,1.0/num_var));
  //scanf("%f",&dshare);
  dshare = 0.5 * pow (0.1, 1.0 / num_var);	//Flou_ran(0.5); // --------------------------------------------------->
  // printf("\nReports to be printed ----- ? (y/n)  : ");
  do
    {
      // ans = getchar();       --------------------------------------------------->
      ans = 'y';
    }
  while (ans != 'y' && ans != 'n');
  if (ans == 'y')
    REPORT = TRUE;
  else
    REPORT = FALSE;
  //les_parametres
  // printf("\nPopulation Size ? (~ 20 times N) ---- : ");
  //scanf("%d", &pop_size );           //----------------------------00000000000000000000000000000000000000000000000000000000000----------------------->
  pop_size = POP_SIZE;
  if (pop_size > MAXPOPSIZE)
    {
      printf ("\n Increase the value of MAXPOPSIZE in program");
      printf ("  and re-run the program");
      exit (-1);
    }

  // printf("\nCross Over Probability ? ( 0.7 to 1 )  : "); // ------------------000000000000000000000000000000000000000000000000000000000000------------------->
  // scanf("%f",&p_xover);
  p_xover = P_XOVER;
  // printf("\nMutation Probability ? ( 0 to 0.2 ) -- : "); // ---------------0000000000000000000000000000000000000000000000000000000000000000-------------->
  // scanf("%f",&p_mutation);
  p_mutation = P_MUTATION;		//Flou_ran(0.05);
  //printf("\n Give the strategy for X-over");
  //  printf("\n 1 : Single-point crossover");
  // printf("\n 2 : Uniform crossover");
  // printf("\n Give your choice -------------(1/2) : ");
  // scanf("%d",&x_strategy);               // ---------------------------------------------->
  x_strategy = 1;
  if (REALGA)
    {
      printf ("\nDistribution Index for crossover and mutation (30 50) : ");
      scanf ("%f %f", &n_distribution_c, &n_distribution_m);
    }

  //printf("\nHow many generations (100) ? --------- : ");  // ---------------*********************************------------->
  //scanf("%d",&max_gen);
  max_gen = MAX_GENERATION;
  //printf("\nGive random seed (0 to 1.0)          : "); // ------------------------------------------------>
  //scanf("%f",&seed);
  seed = 0.5;			//Flou_ran(1.0);
  input_app_parameters ();
}

		/*====================================================================
		  Initialses zero'th generation and global parameters
		  ====================================================================*/
/*
initialize ()
{
  float u;
  int tmp, k, k1, i, j, j1, stop;
  double temp[MAXVECSIZE], coef;
  unsigned mask = 1, nbytes;

  randomize ();
  app_initialize ();
  set_seuil_couv_et_conn();
  oldpop = (INDIVIDUAL *) malloc (pop_size * sizeof (INDIVIDUAL));
  newpop = (INDIVIDUAL *) malloc (pop_size * sizeof (INDIVIDUAL));
  if (oldpop == NULL)
    nomemory ("oldpop in initialize()");
  if (newpop == NULL)
    nomemory ("newpop in initialize()");

  if (BINGA)
    {
      chromsize = (TotalChromLength / UINTSIZE);
      if (TotalChromLength % UINTSIZE)
	chromsize++;
      nbytes = chromsize * sizeof (unsigned);

      for (j = 0; j < pop_size; j++)
	{
	  if ((oldpop[j].chrom = (unsigned *) malloc (nbytes)) == NULL)
	    nomemory ("oldpop chromosomes");

	  if ((newpop[j].chrom = (unsigned *) malloc (nbytes)) == NULL)
	    nomemory ("newpop chromosomes");
	}
    }

  // Initializing continuous, integer
     // and enumerated variables
  for (k = 0; k <= pop_size - 1; k++)
    {
      oldpop[k].flag = 0;
      oldpop[k].parent1 = oldpop[k].parent2 = 0;
      oldpop[k].dumfitness = 0.0;
      for (j = 0; j <= num_var - 1; j++)
	{
	  if (var_type[j] != BIN)
	    {
	      u = randomperc ();
	      oldpop[k].x[j] = x_lower[j] * (1 - u) + x_upper[j] * u;

	      if ((var_type[j] == INT) || (var_type[j] == ENUM))
		{
		  for (k1 = 0; k1 < num_enum_data[j] - 1; k1++)
		    {
		      if (oldpop[k].x[j] < EnumData[j][0])
			{
			  oldpop[k].x[j] = EnumData[j][0];
			  continue;
			}
		      else if (oldpop[k].x[j] >
			       EnumData[j][num_enum_data[j] - 1])
			{
			  oldpop[k].x[j] = EnumData[j][num_enum_data[j] - 1];
			  continue;
			}
		      else if ((EnumData[j][k1] < oldpop[k].x[j]) &&
			       (EnumData[j][k1 + 1] > oldpop[k].x[j]))
			oldpop[k].x[j] =
			  ((EnumData[j][k1 + 1] - oldpop[k].x[j]) >
			   (oldpop[k].x[j] -
			    EnumData[j][k1])) ? EnumData[j][k1] :
			  EnumData[j][k1 + 1];
		    }
		}
	    }
	}

      //  Initializing chromosomes
         // for binary variables

      // trouver le nombre des capteurs qui peuvent donner une solution optimal:
      int Num_cap_intial = (longeur * largeur) / pow ((Rs * 2), 2);
      //printf("\nNum_cap_intial %d", Num_cap_intial);
      // initisation par 0:
      for (k1 = 0; k1 < chromsize; k1++)
	{
	  oldpop[k].chrom[k1] = 0;
	}



NUM_CAPTEUR_INI=Num_cap_intial+INITIAL_CAP;

      //mettre les capteurs:
      for (int i = 0; i < NUM_CAPTEUR_INI ; i++)
	{
	  k1 = IntRand (0, chromsize - 1);
	  int x;
	  if (k1 == (chromsize - 1))
	    {
	      stop = TotalChromLength - (k1 * UINTSIZE);	// "stop": la taille de chaque partier de chromosome
	      x = pow (2, IntRand (0, stop - 1));
	    }
	  else
	    {
	      stop = UINTSIZE;	// UINTSIZE=32.
	      x = pow (2, IntRand (0, stop - 2));	// -2 (non -1)car la taille maximal de int moin de pow (2, 31).
	    }


	  oldpop[k].chrom[k1] = oldpop[k].chrom[k1] | x;
	  //printf("\noldpop[%d].chrom[%d] = oldpop[%d].chrom[%d] + pow (2, %d)>%d", k, k1, k,k1,stop-1,x);



	}


    }

  no_xover = no_mutation = 0;

  init_dum = pop_size;
  min_dum = 0.0;
  delta_dum = 0.1 * init_dum;

  // Decoding binary strings and initializing
     // fitness values for each individual
  for (k = 0; k <= pop_size - 1; k++)
    {
      decode_string (&(oldpop[k]));
      objective (&(oldpop[k]));
    }
}

*/



initialize ()
{
  float u;
  int tmp, k, k1, i, j, j1, stop, valeur;
  double temp[MAXVECSIZE], coef;
  unsigned mask = 1, nbytes;
           int p,k_dep,l_dep,k_stop,l_stop;
         int chromosome[longeur*largeur];

  randomize ();
  app_initialize ();
  set_seuil_couv_et_conn();
  oldpop = (INDIVIDUAL *) malloc (pop_size * sizeof (INDIVIDUAL));
  newpop = (INDIVIDUAL *) malloc (pop_size * sizeof (INDIVIDUAL));
  if (oldpop == NULL)
    nomemory ("oldpop in initialize()");
  if (newpop == NULL)
    nomemory ("newpop in initialize()");

  if (BINGA)
    {
      chromsize = (TotalChromLength / UINTSIZE);
      if (TotalChromLength % UINTSIZE)
	chromsize++;
      nbytes = chromsize * sizeof (unsigned);

      for (j = 0; j < pop_size; j++)
	{
	  if ((oldpop[j].chrom = (unsigned *) malloc (nbytes)) == NULL)
	    nomemory ("oldpop chromosomes");

	  if ((newpop[j].chrom = (unsigned *) malloc (nbytes)) == NULL)
	    nomemory ("newpop chromosomes");
	}
    }

  // Initializing continuous, integer
     // and enumerated variables
  for (k = 0; k <= pop_size - 1; k++)
    {
      oldpop[k].flag = 0;
      oldpop[k].parent1 = oldpop[k].parent2 = 0;
      oldpop[k].dumfitness = 0.0;
      for (j = 0; j <= num_var - 1; j++)
	{
	  if (var_type[j] != BIN)
	    {
	      u = randomperc ();
	      oldpop[k].x[j] = x_lower[j] * (1 - u) + x_upper[j] * u;

	      if ((var_type[j] == INT) || (var_type[j] == ENUM))
		{
		  for (k1 = 0; k1 < num_enum_data[j] - 1; k1++)
		    {
		      if (oldpop[k].x[j] < EnumData[j][0])
			{
			  oldpop[k].x[j] = EnumData[j][0];
			  continue;
			}
		      else if (oldpop[k].x[j] >
			       EnumData[j][num_enum_data[j] - 1])
			{
			  oldpop[k].x[j] = EnumData[j][num_enum_data[j] - 1];
			  continue;
			}
		      else if ((EnumData[j][k1] < oldpop[k].x[j]) &&
			       (EnumData[j][k1 + 1] > oldpop[k].x[j]))
			oldpop[k].x[j] =
			  ((EnumData[j][k1 + 1] - oldpop[k].x[j]) >
			   (oldpop[k].x[j] -
			    EnumData[j][k1])) ? EnumData[j][k1] :
			  EnumData[j][k1 + 1];
		    }
		}
	    }
	}

      //  Initializing chromosomes
         // for binary variables

      // trouver le nombre des capteurs qui peuvent donner une solution optimal:
      int Num_cap_intial = (longeur * largeur) / pow ((Rs * 2), 2);
      //printf("\nNum_cap_intial %d", Num_cap_intial);
      // initisation par 0:
      for (k1 = 0; k1 < chromsize; k1++)
	{
	  oldpop[k].chrom[k1] = 0;
	}








          i=IntRand(0,largeur-1);
          j= IntRand(0,longeur-1);


         //initialisation
         for(int h=0;h<longeur*largeur;h++)
         chromosome[h]=0;




         NUM_CAPTEUR_INI=Num_cap_intial+INITIAL_CAP;

      //mettre les capteurs:
      for (int h = 0; h < NUM_CAPTEUR_INI ; h++)
	{


			  //indices de depart
	  if (i - Distan_entr_cap_ini < 0)
	    k_dep = 0;
	  else
	    k_dep = i - Distan_entr_cap_ini;
	  if (j - Distan_entr_cap_ini < 0)
	    l_dep = 0;
	  else
	    l_dep = j - Distan_entr_cap_ini;
	  // indices d'arrive
	  if (i + Distan_entr_cap_ini > largeur - 1)
	    {
	      k_stop = largeur - 1;
	    }
	  else
	    k_stop = i + Distan_entr_cap_ini;
	  if (j + Distan_entr_cap_ini > longeur - 1)
	    l_stop = longeur - 1;
	  else
	    l_stop = j + Distan_entr_cap_ini;


                  // printf("(%d , %d) - (%d , %d) - (%d , %d) \n",i,j,k_dep,l_dep,k_stop,l_stop);


         i=IntRand(k_dep,k_stop);
         j= IntRand(l_dep,l_stop);

         p=get_position(i,j);
         // printf("(%d , %d) >> %d\n",i,j,p);
         chromosome[p]=1;






	}// fin NUM_CAPTEUR_INI

// printf("\n");
// for(int i=0; i<longeur*largeur; i++){
	// printf("%d",chromosome[i]);
// }
// printf("\n");

  //-----------------------------------------------------  remplir le chrom par le tableau temp: -------------------------------
  int m = 0;
  for (k1 = 0; k1 < chromsize; k1++)
    {

      if (k1 == (chromsize - 1))
	stop = TotalChromLength - (k1 * UINTSIZE);
      else
	stop = UINTSIZE;
      valeur = 0;
      for (j = 0; j < stop; j++)
	{
	  if (chromosome[m] == 1)
	    {
	      valeur = valeur + pow (2, j);
	      //printf("%d-",m+1);
	    }
	  m++;

	}
	oldpop[k].chrom[k1] = valeur;
	    // printf("%d - ",chrom[k1]);

    }

// printf("\n");
















    }// fin Population

  no_xover = no_mutation = 0;

  init_dum = pop_size;
  min_dum = 0.0;
  delta_dum = 0.1 * init_dum;

  // Decoding binary strings and initializing
     // fitness values for each individual
  for (k = 0; k <= pop_size - 1; k++)
    {
      decode_string (&(oldpop[k]));
      objective (&(oldpop[k]));
    }
}





		/*====================================================================
		  Decodes the string of the individual (if any) and puts the values in
		  the array of floats.
		  ====================================================================*/
decode_string (ptr_indiv)
     INDIVIDUAL *ptr_indiv;
{
  double *temp, coef[MAXVECSIZE];
  int j;

  if (ptr_indiv == NULL)
    error_ptr_null ("ptr_indiv in decode_string");
  if (BINGA)
    {
      temp = (double *) malloc (num_var * sizeof (double));

      for (j = 0; j < num_var; j++)
	temp[j] = 0.0;

      decodevalue (ptr_indiv->chrom, temp);

      for (j = 0; j < num_var; j++)
	if (var_type[j] == BIN)
	  {
	    coef[j] = pow (2.0, (double) (lchrom[j])) - 1.0;
	    temp[j] = temp[j] / coef[j];
	    ptr_indiv->x[j] =
	      temp[j] * x_upper[j] + (1.0 - temp[j]) * x_lower[j];
	  }
      free (temp);
    }
}

		/*====================================================================
		  Prints an error message and terminates the program
		  ====================================================================*/
nomemory (string)
     char *string;
{
  printf ("\nmalloc: out of memory making %s!!\n", string);
  printf ("\n Program is halting .....");
  exit (-1);
}

		/*==============================================================
		  Gives error message of null pointer  and terminates the program.
		  ==============================================================*/
error_ptr_null (string)
     char *string;
{
  printf ("\n Error !! Pointer %s found Null !", string);
  printf ("\n Program is halting .....");
  exit (-1);
}

		/*====================================================================
		  Calculates statistics of current generation :
		  ====================================================================*/
statistics (pop, gen)
     POPULATION pop;
     int gen;
{
  int j, iobj;
  float dumsumfit = 0.0;
  float sumfitness[MAXOBJ];

  for (iobj = 0; iobj < num_obj; iobj++)
    {
      minf[iobj] = maxf[iobj] = 1.0e8;
      sumfitness[iobj] = 0.0;
    }

  for (j = 0; j <= pop_size - 1; j++)
    {
      dumsumfit += pop[j].dumfitness;
      for (iobj = 0; iobj < num_obj; iobj++)
	{
	  sumfitness[iobj] += pop[j].fitness[iobj];
	  if (pop[j].fitness[iobj] > maxf[iobj])
	    maxf[iobj] = pop[j].fitness[iobj];
	  if (pop[j].fitness[iobj] < minf[iobj])
	    minf[iobj] = pop[j].fitness[iobj];
	}
    }

  dum_avg = dumsumfit / (double) pop_size;
  for (iobj = 0; iobj < num_obj; iobj++)
    avgfitness[iobj] = sumfitness[iobj] / (double) pop_size;

  app_statistics ();
}

		/*====================================================================
		  Decodes the value of a group of binary strings and puts the decoded
		  values into an array 'value'.
		  ====================================================================*/
decodevalue (chrom, value)
     unsigned *chrom;
     double value[];
{
  int temp, k, count, tp, mask = 1, sumlengthstring, stop, j, PrevTrack;
  int bitpos, flag1, flag2;
  int CountTrack;
  double pow (), bitpow;

  if (BINGA == FALSE)
    return;
  if (chrom == NULL)
    error_ptr_null ("chrom in decodevalue");

  for (count = 0; count < num_var; count++)
    value[count] = 0;

  for (k = 0; k < chromsize; k++)
    {
      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      /* loop thru bits in the current byte */
      tp = chrom[k];
      for (j = 0; j < stop; j++)
	{
	  bitpos = j + k * UINTSIZE;
	  /* test for current bit 0 or 1 */
	  if ((tp & mask) == 1)
	    {
	      sumlengthstring = 0;
	      flag1 = FALSE;
	      flag2 = FALSE;	/* To keep track of the
				   position of 'j' in the chromosome */
	      for (count = 0; count < num_var; count++)
		{
		  if ((var_type[count] == BIN) && (!flag2))
		    {
		      if (bitpos >= sumlengthstring)
			flag1 = TRUE;
		      else
			flag1 = FALSE;
		      sumlengthstring += lchrom[count];
		      if ((bitpos < sumlengthstring) && (flag1))
			{
			  flag2 = TRUE;
			  CountTrack = count;
			  PrevTrack = sumlengthstring - lchrom[count];
			}	/* End of if (bitpos...)  */
		    }		/* End of if (vartype...) */
		}		/* End of for (count)     */

	      bitpow = pow (2.0, (double) (bitpos - PrevTrack));
	      value[CountTrack] += bitpow;
	    }			/* End of if (tp&mask) */
	  tp = tp >> 1;
	}			/* End of for (j) */
    }				/* End of for (k) */
}

		/*====================================================================
		  GENERATION OF NEW POPULATION through SELECTION, XOVER & MUTATION :
		  ====================================================================*/
generate_new_pop ()
{
  int j, k, k1, mate1, mate2,connexite;
  float taux_conn;
  app_computation ();
  preselect ();
  // for (k = 0; k <= pop_size - 1; k =k+2)
  for (k = 0; k <= pop_size - 1; k++)

    {

      do{

	  mate1 = select ();	/* Stoc. Rem. Roulette Wheel Selection */
	  mate2 = select ();
	  nremain--;


	  switch (x_strategy)	/* Crossover */
	    {
	    case ONESITE:
	      //cross_over_1_site (mate1, mate2, k, k + 1);

	      cross_over_1_site (mate1, mate2, k);

	      break;
	    case UNIF:
	      // cross_over_unif (mate1, mate2, k, k + 1);
	      cross_over_unif (mate1, mate2, k);

	      break;
	    }

	  mutation (&newpop[k]);	/* Mutation */

	  decode_string (&(newpop[k]));
	  update_x_BIN_ENUM (&(newpop[k]));
	  objective (&(newpop[k]));
	  if(contrainte_connectivite>0){
	  connective_connexite (&taux_conn, &connexite);
	  if (taux_conn != 100.0 || connexite==0)
	    nremain++;
	  }
	}
      while (contrainte_connectivite>0 && (taux_conn != 100.0 || connexite==0));

      MAJ_meilleur_couvr();
	  // printf("\n-------------------------------------------------------------------------------------\n");
	  	     // printf("                                                                                     |");
      // printf("\nGn=%d - n= %d taux_connectivite=%f  connexite=%d\n",gen_no,k+1,taux_conn,connexite);
	  	     // printf("                                                                                     |");
	  // printf("\n-------------------------------------------------------------------------------------\n");

      newpop[k].parent1 = mate1 + 1;
      newpop[k].parent2 = mate2 + 1;


      /*
         mutation (&newpop[k + 1]);
         decode_string (&(newpop[k + 1]));
         update_x_BIN_ENUM (&(newpop[k + 1]));
         objective (&(newpop[k + 1]));
         newpop[k + 1].parent1 = mate1 + 1;
         newpop[k + 1].parent2 = mate2 + 1;
       */


    }


}

		/***************************************************************
		  For integer and enumerated data, a permissible solution is
		  calculated here
		  **************************************************************/
update_x_BIN_ENUM (indv)
     INDIVIDUAL *indv;
{
  int j, k1;

  for (j = 0; j < num_var; j++)
    if ((var_type[j] == INT) || (var_type[j] == ENUM))
      {
	for (k1 = 0; k1 < num_enum_data[j] - 1; k1++)
	  {
	    if (indv->x[j] < EnumData[j][0])
	      {
		indv->x[j] = EnumData[j][0];
		continue;
	      }
	    else if (indv->x[j] > EnumData[j][num_enum_data[j] - 1])
	      {
		indv->x[j] = EnumData[j][num_enum_data[j] - 1];
		continue;
	      }
	    else if ((EnumData[j][k1] < indv->x[j]) &&
		     (EnumData[j][k1 + 1] > indv->x[j]))
	      indv->x[j] = ((EnumData[j][k1 + 1] - indv->x[j]) >
			    (indv->x[j] - EnumData[j][k1])) ?
		EnumData[j][k1] : EnumData[j][k1 + 1];
	  }			/* End of for (k1) */
      }
}

		/*====================================================================
		  Binary cross over routine.
		  ====================================================================*/
		 //binary_xover (parent1, parent2, child1)
		 //    unsigned *parent1, *parent2, *child1;
binary_xover (parent1, parent2, child1, child2)
     unsigned *parent1, *parent2, *child1, *child2;
		/* Cross 2 parent strings, place in 2 child strings */
{
  int j, jcross, k;
  unsigned mask, temp;

  if (BINGA == FALSE)
    return;
  if (parent1 == NULL)
    error_ptr_null ("parent1 in binary_xover");
  if (parent2 == NULL)
    error_ptr_null ("parent2 in binary_xover");
  if (child1 == NULL)
    error_ptr_null ("child1 in binary_xover");
  if (child2 == NULL)
    error_ptr_null ("child2 in binary_xover");
  jcross = rnd (1, (TotalChromLength - 1));	/* Cross between 1 and l-1 */
  for (k = 1; k <= chromsize; k++)
    {
      if (jcross >= (k * UINTSIZE))
	{
	  //printf("\n-------- %d %d -----------\n",jcross,(k * UINTSIZE));
	  child1[k - 1] = parent1[k - 1];
	  child2[k - 1] = parent2[k - 1];
	}
      /*
         else if ((jcross < (k * UINTSIZE)) && (jcross > ((k - 1) * UINTSIZE)))
         {
         mask = 1;
         for (j = 1; j <= (jcross - 1 - ((k - 1) * UINTSIZE)); j++)
         {
         temp = 1;
         mask = mask << 1;
         mask = mask | temp;
         }
         child1[k - 1] =
         (parent1[k - 1] & mask) | (parent2[k - 1] & (~mask));
         child2[k - 1] = (parent1[k - 1] & (~mask)) | (parent2[k - 1] & mask);
         }
       */
      else
	{
	  child1[k - 1] = parent2[k - 1];
	  child2[k - 1] = parent1[k - 1];
	}
    }
}

		/*====================================================================
		  Creates two children from parents p1 and p2, stores them in addresses
		  pointed by c1 and c2.  low and high are the limits for x values and
		  rand_var is the random variable used to create children points.
		  ====================================================================*/
create_children (p1, p2, c1, c2, low, high, RIGID)
     float p1, p2, *c1, *c2, low, high;
     int RIGID;
{
  float difference, x_mean, beta, temp;
  float u, u_l, u_u, beta_l = 0.0, beta_u = 0.0, beta1 = 0.0, beta2 = 0.0;
  int flag;


  if (c1 == NULL)
    error_ptr_null ("c1 in create_children");
  if (c2 == NULL)
    error_ptr_null ("c2 in create_children");
  flag = 0;
  if (p1 > p2)
    {
      temp = p1;
      p1 = p2;
      p2 = temp;
      flag = 1;
    }
  x_mean = (p1 + p2) * 0.5;
  difference = p2 - p1;
  if (difference <= 1.0e-9)
    {
      *c1 = p1;
      *c2 = p2;
    }
  else
    {
      if (RIGID)
	{
	  beta_l = 1.0 + 2.0 * (p1 - low) / (p2 - p1);
	  beta_u = 1.0 + 2.0 * (high - p2) / (p2 - p1);
	  if (MINSCHEME)
	    {
	      if (beta_l <= beta_u)
		beta_u = beta_l;
	      else
		beta_l = beta_u;
	      u = rndreal (0.0, 1.0);
	      beta1 = beta2 = get_beta_rigid (u, beta_l);
	    }
	  else
	    {
	      u_l = rndreal (0.0, 1.0);
	      beta1 = get_beta_rigid (u_l, beta_l);

	      u_u = rndreal (0.0, 1.0);
	      beta2 = get_beta_rigid (u_u, beta_u);
	    }
	}
      else
	{
	  u = rndreal (0.0, 1.0);
	  beta1 = beta2 = get_beta (u);
	}
      *c1 = x_mean - beta1 * 0.5 * difference;
      *c2 = x_mean + beta2 * 0.5 * difference;
    }
  if (flag == 1)
    {
      temp = *c1;
      *c1 = *c2;
      *c2 = temp;
    }
  if (*c1 < low)
    *c1 = low;
  if (*c2 > high)
    *c2 = high;

  if (*c1 < low || *c2 > high)
    {
      printf ("Error!! p1 = %f, p2 = %f, c1 = %f, c2 = %f\n", p1, p2, *c1,
	      *c2);
      exit (-1);
    }
}

		/*====================================================================
		cross over using strategy of 1 cross site with swapping .
		  A random variable is chosen and crossed over. The variables on left
		  side are passed as it is and those on right are swapped between the
		  two parents.
		====================================================================*/

		// cross_over_1_site (first, second, childno1, childno2)
			 // int first, second, childno1, childno2;
cross_over_1_site (first, second, childno1)
     int first, second, childno1;
{
  int j, k, site;

  if (flip (p_xover))		/* Cross over has to be done */
    {
      no_xover++;

      //printf("\nfirst=%d   ,  second=%d    , childno1=%d\n",first,second,childno1);
      if (BINGA)
	// binary_xover (oldpop[first].chrom, oldpop[second].chrom, newpop[childno1].chrom, newpop[childno2].chrom);
	binary_xover (oldpop[first].chrom, oldpop[second].chrom,
		      newpop[childno1].chrom);


      site = rnd (0, num_var - 1);


      /*
         for (k = 0; k <= site - 1; k++)
         if (var_type[site] != BIN)
         {
         newpop[childno1].x[k] = oldpop[first].x[k];
         newpop[childno2].x[k] = oldpop[second].x[k];
         }

         for (k = site + 1; k <= num_var - 1; k++)
         if (var_type[site] != BIN)
         {
         newpop[childno2].x[k] = oldpop[first].x[k];
         newpop[childno1].x[k] = oldpop[second].x[k];
         }
       */
      /* If variable != BINARY create children
         at the cross site variable */
      /*
         if (var_type[site] != BIN)
         create_children (oldpop[first].x[site], oldpop[second].x[site],
         &(newpop[childno1].x[site]),
         &(newpop[childno2].x[site]),
         x_lower[site], x_upper[site], var_RIGID[site]);
       */
    }				/* Cross over done */

  else				/* Passing x-values straight */
    {
      if (BINGA)
	for (k = 0; k <= chromsize; k++)
	  {
	    newpop[childno1].chrom[k] = oldpop[first].chrom[k];
	    // newpop[childno2].chrom[k] = oldpop[second].chrom[k];
	    //printf("%d ",newpop[childno1].chrom[k]);
	  }
      //printf("\n");
      for (k = 0; k <= num_var - 1; k++)
	{

	  newpop[childno1].x[k] = oldpop[first].x[k];
	  // newpop[childno2].x[k] = oldpop[second].x[k];
	  // printf("%d ",newpop[childno1].x[k]);
	}
      // printf("\n");

    }
}

		/*====================================================================
		CROSS - OVER  USING strategy of uniform 50% variables
		  For one variable problem, it is crossed over as usual.
		  For multivariables, each variable is crossed over with a probability
		  of 50 % , each time generating a new random beta.
		====================================================================*/

		// cross_over_unif (first, second, childno1, childno2)
			// int first, second, childno1, childno2;
cross_over_unif (first, second, childno1)
     int first, second, childno1;
{
  float difference, x_mean, beta;
  int site, k;

  if (flip (p_xover))		/* Cross over has to be done */
    {
      no_xover++;
      if (BINGA)
	binary_xover (oldpop[first].chrom, oldpop[second].chrom,
		      newpop[childno1].chrom);
      // binary_xover (oldpop[first].chrom, oldpop[second].chrom,  newpop[childno1].chrom, newpop[childno2].chrom);

      /*
         for (site = 0; site <= num_var - 1; site++)
         {
         if (var_type[site] != BIN)
         if (flip (0.5) || (num_var == 1))
         {
         create_children (oldpop[first].x[site],
         oldpop[second].x[site],
         &(newpop[childno1].x[site]),
         &(newpop[childno2].x[site]), x_lower[site],
         x_upper[site], var_RIGID[site]);
         }
         else
         {
         newpop[childno1].x[site] = oldpop[first].x[site];
         //newpop[childno2].x[site] = oldpop[second].x[site];
         }
         } *//* for loop */
    }				/* Cross over done */

  else				/* Passing x-values straight */
    {
      if (BINGA)
	for (k = 0; k <= chromsize; k++)
	  {
	    newpop[childno1].chrom[k] = oldpop[first].chrom[k];
	    // newpop[childno2].chrom[k] = oldpop[second].chrom[k];
	  }
      for (site = 0; site <= num_var - 1; site++)
	{
	  newpop[childno1].x[site] = oldpop[first].x[site];
	  // newpop[childno2].x[site] = oldpop[second].x[site];
	}
    }
}

		/*===================================================================
		Calculates beta value for given random number u (from 0 to 1)
		If input random numbers (u) are uniformly distributed for a set of
		inputs, Binary Probability distribution simulation
		====================================================================*/
float
get_beta (u)
     float u;
{
  float beta;

  if (1.0 - u < EPSILON)
    u = 1.0 - EPSILON;
  if (u < 0.0)
    u = 0.0;
  if (u < 0.5)
    beta = pow (2.0 * u, (1.0 / (n_distribution_c + 1.0)));
  else
    beta = pow ((0.5 / (1.0 - u)), (1.0 / (n_distribution_c + 1.0)));
  return (beta);
}

		/*****************************************************************
		  Calculates beta for rigid boundaries
		  ****************************************************************/
float
get_beta_rigid (u, betaa)
     float u, betaa;
{
  float bet, beta;

  if (u <= 0.0 + 1.0e-9)
    beta = 0.0;
  else if (u >= 1.0 - 1.0e-9)
    beta = betaa;
  else
    {
      bet = 1.0 / betaa;
      bet = 2.0 - pow (bet, (n_distribution_c + 1.0));
      if (u <= 1.0 / bet)
	beta = pow (bet * u, (1.0 / (n_distribution_c + 1.0)));
      else
	beta = pow (1.0 / (2.0 - u * bet), (1.0 / (n_distribution_c + 1.0)));
    }
  return beta;
}

		/*==================================================================
		For given u value such that   -1 <= u <= 1, this routine returns a
		value of delta from -1 to 1. Exact value of delta depends on specified
		n_distribution. This is called by mutation().
		====================================================================*/
float
get_delta (u, delta_l, delta_u)
     float u, delta_l, delta_u;
{
  float delta, aa;

  if (u >= 1.0 - 1.0e-9)
    delta = delta_u;
  else if (u <= 0.0 + 1.0e-9)
    delta = delta_l;
  else
    {
      if (u <= 0.5)
	{
	  aa = 2.0 * u + (1.0 - 2.0 * u) * pow ((1 + delta_l),
						(n_distribution_m + 1.0));
	  delta = pow (aa, (1.0 / (n_distribution_m + 1.0))) - 1.0;
	}
      else
	{
	  aa = 2.0 * (1 - u) + 2.0 * (u - 0.5) * pow ((1 - delta_u),
						      (n_distribution_m +
						       1.0));
	  delta = 1.0 - pow (aa, (1.0 / (n_distribution_m + 1.0)));
	}
    }
  if (delta < -1.0 || delta > 1.0)
    {
      printf ("Error in mutation!! delta = %f\n", delta);
      exit (-1);
    }
  return (delta);
}

		/*==================================================================
		Binary mutation routine ( borrowed from sga.c )
		====================================================================*/


binmutation (chrom)
     unsigned *chrom;
{

  int j, k, stop, count = 0, num_sensor = 0, c, i_rand, valeur,i_rand2;
  unsigned mask = 1, tmp;
  int temp[longeur * largeur];

for(int i=0;i<longeur*largeur;i++)
temp[i]=0;



     // printf("\n.\n.\n.\nle tableau chrom:\n");
     // for(int i=chromsize-1; i>=0;i--)
     // printf("%d  -  ",chrom[i]);


  // 1)  convertir le chrom C  un tableau:


  for (k = 0; k < chromsize; k++)
    {
      tmp = chrom[k];
      //printf("\n%d",tmp);
      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;

      for (j = 0; j < stop; j++)
	{
	  if (tmp & mask)
	    {
	      temp[j + count * UINTSIZE] = 1;
	      //printf("%d",temp[j + count * UINTSIZE]);
	    }
	  else
	    {
	      temp[j + count * UINTSIZE] = 0;
	      //printf("%d",temp[j + count * UINTSIZE]);

	    }
	  tmp = tmp >> 1;
	}
      count++;
    }






  // 2) la mutation:
  for (int i = 0; i < NUM_MUT_BIT; i ++)
    {
      i_rand = IntRand (0, (longeur * largeur) - 1);	// choisir un indice aleatoire.
	  i_rand2 = IntRand (0, (longeur * largeur) - 1);
      c = temp[i_rand];
      temp[i_rand] = temp[i_rand2];
      temp[i_rand2] = c;
      // printf("%d",temp[i]);
    }

//printf("\navg=%d\n",(int)avgfitness[0]);
//pour augmenter le nombre des capteurs
if((int)avgfitness[0]<NUM_CAPTEUR_INI)
    for(int h=0;h<NUM_PUT_CAP;h++)
	temp[IntRand (0, (longeur * largeur) - 1)] = 1;

// pour minimiser le nombre des capteurs
if((int)avgfitness[0]>NUM_CAPTEUR_INI+MAX_CAPTEUR)
    for(int h=0;h<(longeur*largeur)/10 ;h++)
	temp[IntRand (0, (longeur * largeur) - 1)] = 0;

else
	temp[IntRand (0, (longeur * largeur) - 1)] = 1;

	     // if (flip (1))  temp[IntRand (0, (longeur * largeur) - 1)] = 1;





  // 3) remplir le chrom par le tableau temp:
  int m = longeur*largeur-1;
  for (k = 0; k < chromsize; k++)
    {

      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      valeur = 0;
      for (j = 0; j < stop; j++)
	{
	  if (temp[m] == 1)
	    {
	      valeur = valeur + pow (2, j);
	      //printf("%d-",m+1);
	    }
	  m--;

	}
	chrom[k] = valeur;
	    // printf("%d - ",chrom[k]);

    }

// printf("\n");




}


		// binmutation(child)
// unsigned *child;
// {
    // int j, k, stop;
    // unsigned mask, temp = 1;

    // if (BINGA == FALSE) return;
    // if (child== NULL) error_ptr_null(" child in binmutation");
    // for(k = 0; k < chromsize; k++)
    // {
        // mask = 0;
        // if(k == (chromsize-1))
            // stop = TotalChromLength - ((k-1)*UINTSIZE);
        // else
            // stop = UINTSIZE;
        // for(j = 0; j < stop; j++)
        // {
            // if(flip(p_mutation))
            // {
                // mask = (mask|(temp<<j));
            // }
			// else    mask = !(mask|(temp<<j));

        // }
        // child[k] = child[k] + mask;
    // }
// }


		/*===================================================================
		Mutation Using polynomial probability distribution. Picks up a random
		site and generates a random number u between -1 to 1, ( or between
		minu to maxu in case of rigid boudaries) and calls the routine
		get_delta() to calculate the actual shift of the value.
		====================================================================*/
mutation (indiv)
     INDIVIDUAL *indiv;
{
  float distance, x, delta, u, delta_l, delta_u;
  int k, site;

  if (indiv == NULL)
    error_ptr_null ("indiv in mutation");

  if (flip (p_mutation))
    no_mutation++;
  if (flip (p_mutation) && REALGA)
    {

      site = rnd (0, num_var - 1);

      if (var_type[site] != BIN)
	{


	  if (fabs (x_upper[site] - x_lower[site]) < EPSILON)
	    return;

	  // calculation of bounds on delta
	  if (var_RIGID[site])
	    {
	      x = indiv->x[site];
	      distance = x_lower[site] - x;
	      delta_l = distance / (x_upper[site] - x_lower[site]);
	      if (delta_l < -1.0)
		delta_l = -1.0;

	      distance = x_upper[site] - x;
	      delta_u = distance / (x_upper[site] - x_lower[site]);
	      if (delta_u > 1.0)
		delta_u = 1.0;

	      if (MINSCHEME)
		{
		  if (-1.0 * delta_l < delta_u)
		    delta_u = -1.0 * delta_l;
		  else
		    delta_l = -1.0 * delta_u;
		}
	    }
	  else			// flexible
	    {
	      delta_l = -1.0;
	      delta_u = 1.0;
	    }
	  u = rndreal (0.0, 1.0);
	  delta = get_delta (u, delta_l, delta_u)
	    * (x_upper[site] - x_lower[site]);
	  indiv->x[site] += delta;
	}

    }				// if flip()

  if (BINGA)
    if (flip (p_mutation))
      binmutation (indiv->chrom);
}

		/*====================================================================
		  Reporting the user-specified parameters :
		fp is the file pointer to output file.
		====================================================================*/
initreport (fp)
     FILE *fp;
{
  int k, iobj;

  if (fp == NULL)
    error_ptr_null (" File fp in initreport");
  fprintf (fp, "\n=============================================");
  fprintf (fp, "\n             INITIAL REPORT                  ");
  fprintf (fp, "\n=============================================");
  fprintf (fp, "\n");
  fprintf (fp, "\n Number of objective functions : %2d", num_obj);
  for (iobj = 0; iobj < num_obj; iobj++)
    {
      fprintf (fp, "\n   Objective function #%2d : ", iobj + 1);
      if (minmax[iobj] == 1)
	fprintf (fp, "Minimize");
      else if (minmax[iobj] == -1)
	fprintf (fp, "Maximize");
    }
  fprintf (fp, "\n\n CROSSOVER TYPE             : ");
  if (BINGA)
    fprintf (fp, "Binary GA (Single-pt)");
  fprintf (fp, "\n                              ");
  switch (x_strategy)
    {
    case ONESITE:
      fprintf (fp,
	       "\n STRATEGY                   : 1 cross - site with swapping");
      break;
    case UNIF:
      fprintf (fp,
	       "\n STRATEGY                   : Uniformly all variables 50 % ");
      break;
    default:
      fprintf (fp, "\n CROSS OVER NOT SET CORRECTLY ");
      break;
    }
  fprintf (fp, "\n Population size            : %d", pop_size);
  fprintf (fp, "\n Total no. of generations   : %d", max_gen);
  fprintf (fp, "\n Cross over probability     : %6.4f", p_xover);
  fprintf (fp, "\n Mutation probability       : %6.4f", p_mutation);
  if (BINGA)
    fprintf (fp, "\n String length              : %d", TotalChromLength);
  fprintf (fp, "\n Number of variables");
  fprintf (fp, "\n                Binary      : %d", num_bin_var);
  fprintf (fp, "\n                Integer     : %d", num_int_var);
  fprintf (fp, "\n                Enumerated  : %d", num_enum_var);
  fprintf (fp, "\n                Continuous  : %d", num_cont_var);
  fprintf (fp, "\n                  TOTAL     : %d", num_var);
  fprintf (fp, "\n Epsilon for closeness      : %g", closeness);
  if (REALGA)
    {
      fprintf (fp, "\n Distribution Index (cross) : %g", n_distribution_c);
      fprintf (fp, "\n Distribution Index (mut)   : %g", n_distribution_m);
    }
  fprintf (fp, "\n Sigma-share value          : %6.4f", dshare);
  fprintf (fp, "\n Sharing Strategy           : ");
  if (PARAM)
    fprintf (fp, "sharing on Parameter Space");
  else if (FITNESS)
    {
      fprintf (fp, "sharing on Fitness Space");
      for (iobj = 0; iobj < num_obj; iobj++)
	fprintf (fp, "\n Weightage for Obj. Fun. #%2d : %6.4f", iobj + 1,
		 weightage[iobj]);
    }
  fprintf (fp, "\n Lower and Upper bounds     :");
  for (k = 0; k <= num_var - 1; k++)
    fprintf (fp, "\n   %8.4f   <=   x%d   <= %f", x_lower[k], k + 1,
	     x_upper[k]);
  fprintf (fp, "\n=================================================\n");
  app_initreport ();
}

		/*====================================================================
		Writes a given string of 0's and 1's
		puts a `-` between each substring (one substring for one variable)
		Leftmost bit is most significant bit.
		====================================================================*/
writechrom (chrom, fp)
     unsigned *chrom;
     FILE *fp;
{
  int j, k, stop, bits_per_var, count = 0;
  unsigned mask = 1, tmp;
  int temp[longeur * largeur];

  for (j = 0; j < longeur * largeur; j++)
    temp[j] = 0;
  if (fp == NULL)
    error_ptr_null (" File fp in initreport");
  if (BINGA == FALSE)
    return;
  if (chrom == NULL)
    error_ptr_null ("chrom in writechrom");

  for (k = 0; k < chromsize; k++)
    {
      tmp = chrom[k];
      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      for (j = 0; j < stop; j++)
	{
	  if (tmp & mask)
	    {
	      /*fprintf(fp,"1"); */
	      temp[j + count * UINTSIZE] = 1;
	    }
	  else
	    {
	      /*fprintf(fp,"0"); */
	      temp[j + count * UINTSIZE] = 0;
	    }
	  tmp = tmp >> 1;
	}
      count++;
    }

  count = 0;
  for (j = 0; j < num_var; j++)
    {
      for (k = count + lchrom[j] - 1; k >= count; k--)
	{
	  fprintf (fp, "%d", temp[k]);
	}
      count += lchrom[j];
      if (j != num_var - 1)
	fprintf (fp, "_");
    }
}

		/*====================================================================
		Reporting the statistics of current population ( gen. no. 'num'):
		  fp is file pointer to output file.
		====================================================================*/
report (fp, num)
     FILE *fp;
     int num;
{
  int k, j, iobj, f1 = 0, f2 = 0;
  char string[30];

  if (fp == NULL)
    error_ptr_null (" file fp in report()");
  /* ----------------------------------------- */
  /* WRITING IN THE OUTPUT FILE FOR INSPECTION */
  /* ----------------------------------------- */
  fprintf (fp,
	   "\n======================== Generation # : %3d =================================",
	   num);
  if (BINGA)
    fprintf (fp,
	     "\n  No.   Rank         x   Obj. Fun. Values (f1,f2, etc.) Parents   String");
  else
    fprintf (fp,
	     "\n  No.   Rank         x   Obj. Fun. Values (f1,f2, etc.   Parents  ");
  fprintf (fp,
	   "\n-----------------------------------------------------------------------------");
  for (k = 0; k <= pop_size - 1; k++)
    {
      fprintf (fp, "\n %3d.   %3d   [%Lfe] ", k + 1, oldpop[k].front,
	       oldpop[k].x[0]);
      for (j = 1; j <= num_var - 1; j++)
	fprintf (fp, "\n              [%7.3f ] ", oldpop[k].x[j]);
      for (j = 0; j < num_obj; j++)
	{
	  fprintf (fp, " %9.3f ", oldpop[k].fitness[j]);
	  //printf("%9.3f ", oldpop[k].fitness[j]);
	  if (max_gen == num)
	    {
	      if (j == 0)
		{
		  fitness1[f1] = oldpop[k].fitness[j];
		  f1++;
		}
	      if (j == 1)
		{
		  fitness2[f2] = oldpop[k].fitness[j];
		  f2++;
		}

	    }


	}
      //printf(" \n");
      fprintf (fp, " (%3d %3d)", oldpop[k].parent1, oldpop[k].parent2);
      if (BINGA)
	{
	  fprintf (fp, "     ");
	  writechrom (oldpop[k].chrom, fp);
	}
    }
  fprintf (fp,
	   "\n-----------------------------------------------------------------------------");
  fprintf (fp, "\nAverage Dummy Fitness = %8.3f", dum_avg);
  for (iobj = 0; iobj < num_obj; iobj++)
    fprintf (fp,
	     "\nObj. Function #%2d: Max. Fitness = %8.3f  Min. Fitness = %8.3f  Avg. Fitness = %8.3f",
	     iobj + 1, maxf[iobj], minf[iobj], avgfitness[iobj]);
  fprintf (fp, "\nNo. of mutations = %d ;  No. of x-overs = %d", no_mutation,
	   no_xover);

  fprintf (fp,
	   "\n=============================================================================");
  fprintf (fp, "\n\n");

  //afficher la solution final:
  /*
     printf("fitness 1:\n");
     for (k=0; k<= pop_size-1; k++)
     printf("%f\n",fitness1[k]) ;

     printf("fitness 2:\n");
     for (k=0; k<= pop_size-1; k++)
     printf("%f\n",fitness2[k]) ;
   */

  //ecrire_fichier(fitness1,pop_size);
  //ecrire_fichier(fitness2,pop_size);
  app_report ();
}







		/*====================================================================
		Reporting the statistics of current population ( gen. no. 'num'):
		  fp is file pointer to output file.
		====================================================================*/
result (fp, num)
     FILE *fp;
     int num;
{
  int k, j;
  char string[30];


  if (fp == NULL)
    error_ptr_null (" file fp in report()");

  /* -------------------------------------- */
  /* WRITING IN THE OUTPUT FILE FOR RESULTS */
  /* -------------------------------------- */
  fprintf (fp,
	   "\n#============== Generation # : %3d ===========================================",
	   num);
  if (BINGA)
    fprintf (fp,
	     "\n#  No.          x         Obj. Fun. Values (f1,f2,etc.)     String");
  else
    fprintf (fp,
	     "\n#  No.          x         Obj. Fun. Values (f1,f2,etc.)  ");
  fprintf (fp,
	   "\n#=============================================================================\n");
  for (k = 0; k <= pop_size - 1; k++)
    {
      /* for now deb 14/8/98
         fprintf(fp,"\n %3d. x%d = [%10.3f ]  ",k+1,1,oldpop[k].x[0]);
         for (j= 1; j<=num_var-1; j++)
         fprintf(fp,"\n      x%d = [%10.3f ]   ",j+1,oldpop[k].x[j]);
       */
      for (j = 0; j < num_obj; j++)
	fprintf (fp, " %10.3f ", oldpop[k].fitness[j]);
      /*  if (BINGA)
         {
         fprintf(fp,"        ");
         writechrom(oldpop[k].chrom,fp);
         }
       */
      fprintf (fp, "\n");
    }
  fprintf (fp,
	   "\n#=============================================================================");
  fprintf (fp, "\n\n");

  app_report ();
}

		/*====================================================================
		Releases the memory for all mallocs
		====================================================================*/
free_all ()
{
  int i;

  for (i = 0; i < pop_size; i++)
    {
      free (oldpop[i].chrom);
      free (newpop[i].chrom);
    }
  free (oldpop);
  free (newpop);
  select_free ();
  app_free ();
}

		/*====================================================================
		Population Fronts Created Here

			 Classifying entire population into different fronts
			 and assigning dummy fitness(dumfitness) accordingly.

			 flags as follows  :  flag = 0  for untouched
										 1      dominated
										 2      non-dominated
										 3      exhausted
		====================================================================*/
MakeFronts (void)
{
  int i, j, front_index, pop_count, ijk, iobj, flagobj;

  for (i = 0; i < pop_size; i++)	/* initializing */
    {
      oldpop[i].flag = 0;	/* making all indivs. untouched */
      oldpop[i].dumfitness = 0.0;
    }

  pop_count = 0;		/* for checking if all individuals are
				   assigned a front */

  front_index = 1;		/* first front */
  while (pop_count < pop_size)
    {
      for (j = 0; j < pop_size; j++)
	{
	  if (oldpop[j].flag == 3)
	    continue;		/* already assigned
				   a front, do not consider */

	  for (i = 0; i < pop_size; i++)
	    {
	      if (i == j)
		continue;	/* one is not compared with the same */

	      else if (oldpop[i].flag == 3)
		continue;	/* already assigned */

	      else if (oldpop[i].flag == 1)
		continue;	/* marked dominated */

	      else		/* check for domination */
		{
		  flagobj = 0;
		  for (iobj = 0; iobj < num_obj && !flagobj; iobj++)
		    if (minmax[iobj] * oldpop[j].fitness[iobj] <=
			minmax[iobj] * oldpop[i].fitness[iobj])
		      flagobj = 1;
		  if (flagobj == 0)
		    {
		      oldpop[j].flag = 1;
		      break;
		    }
		}
	    }			/*End of For loop --i-- */

	  if (oldpop[j].flag == 0)	/* non-dominated solutions */
	    {
	      oldpop[j].flag = 2;
	      pop_count++;
	    }
	}			/*End of For loop --j-- */

      if (front_index == 1)
	{
	  /* all in first front are assigned a
	     dummy fitness = popsize */
	  for (i = 0; i < pop_size; i++)
	    if (oldpop[i].flag == 2)
	      {
		oldpop[i].dumfitness = init_dum;
		oldpop[i].front = front_index;
	      }

	  phenoshare ();	/*Phenotypic sharing of non-dominated strings */

	  minimum_dum ();	/* Finding minimum dummy-fitness
				   among shared strings */

	  front_index++;	/* incremented for next front */
	}

      else			/* for all other fronts 2, 3, ... */
	{
	  for (i = 0; i < pop_size; i++)
	    if (oldpop[i].flag == 2)	/* member of current front */
	      {
		oldpop[i].front = front_index;
		if (min_dum > delta_dum)
		  oldpop[i].dumfitness = min_dum - delta_dum;
		/* smaller than the smallest dummy fitness in
		   previous front */
		else
		  adjust (front_index);
	      }

	  phenoshare ();

	  minimum_dum ();

	  front_index++;

	}			/* --if else-- */

      for (i = 0; i < pop_size; i++)
	{
	  /* call members of current front exhausted */
	  if (oldpop[i].flag == 2)
	    oldpop[i].flag = 3;

	  /* and ummark all current dominated solutions */
	  else if (oldpop[i].flag == 1)
	    oldpop[i].flag = 0;
	}

    }				/*End of while loop */

}

adjust (index)
     int index;
{
  /* jack up the fitness of all solutions assigned in a front
     to accomodate remaining ones */
  int i;
  double diff;

  diff = 2.0 * delta_dum - min_dum;
  for (i = 0; i < pop_size; i++)
    if (oldpop[i].flag == 1 || oldpop[i].flag == 0)
      continue;
    else
      oldpop[i].dumfitness += diff;

  minimum_dum ();
}

		/*====================================================================
		  Sharing in a front.  oldpop.dumfitness is divided by nichecount.
		  =====================================================================*/
phenoshare ()
{

  int i, j;
  float dvalue, d, nichecount;
  double pow ();
  float distance ();

  for (j = 0; j < pop_size; j++)
    {
      nichecount = 1.0;
      if (oldpop[j].flag == 2)
	{
	  for (i = 0; i < pop_size; i++)
	    {
	      if (i == j)
		continue;

	      if (oldpop[i].flag == 2)
		{
					/** distance() returns the phenotypic distance between
							  two individuals **/
		  d = distance (&(oldpop[j]), &(oldpop[i]));
		  if (d < 0.0)
		    d = (-1.0) * d;
		  if (d <= 0.000001)
		    nichecount++;
		  else if (d < dshare)
		    nichecount += (1.0 - (d / dshare)) * (1.0 - (d / dshare));
		}
	    }			/* for i loop */
	}			/* for oldpop[j].flag==2 loop */
      oldpop[j].dumfitness /= nichecount;

    }				/* j loop */
}

		/*======================================================
		  distance() returns the phenotypic distance
		  between two individuals :
		  o in n-dimensional space. (number of variables = nx)
		  o in fitness space.       (fitness1 - fitness2 space)
		  =======================================================*/
float
distance (critter1, critter2)
     INDIVIDUAL *critter1;
     INDIVIDUAL *critter2;
{
  int i, iobj;
  double dst, sqrt ();

  dst = 0.0;
  if (FITNESS)			/* Sharing on fitness space */
    {
      for (iobj = 0; iobj < num_obj; iobj++)
	dst +=
	  weightage[iobj] * square (critter1->fitness[iobj] -
				    critter2->fitness[iobj]) /
	  square (afmax[iobj] - afmin[iobj]);
    }
  else if (PARAM)		/* Sharing on parameter space */
    {
      for (i = 0; i < num_var; i++)
	dst +=
	  square (critter1->x[i] - critter2->x[i]) / square (x_upper[i] -
							     x_lower[i]);
    }
  dst = sqrt (dst);
  return (dst);
}

minimum_dum ()
{
  /* finding the minimum dummy fitness in the current front */
  int i;

  min_dum = 1000000000.0;

  for (i = 0; i < pop_size; i++)
    {
      if (oldpop[i].flag == 2)
	{
	  if (oldpop[i].dumfitness < min_dum)
	    min_dum = oldpop[i].dumfitness;
	}
    }
}

void
initialisation_aleatoire ()
{
  // printf("\n pop_size=%d - longeur*largeur=%d", pop_size, longeur*largeur);
  /*

     //initialisation:
     for(int i; i<pop_size; i++){
     for(int j; j<4; j++){
     oldpop[i].chrom[IntRand(0,(longeur*largeur)-1)]=1;
     printf("\n");
     }

     }

     //afichage:
     printf("\n");

     for(int i; i<pop_size; i++){
     //printf("i= %d -->> ", i);
     for(int j; j<longeur*largeur; j++){
     printf("%d",oldpop[i].chrom[j]);
     //printf("j=%d - ",j);
     }
     printf("\n");
     }
   */
}


		/*====================================================================
		  MAIN PROGRAM ;
		  ====================================================================*/
main ()
{
  FILE *fp_out;			/* File pointer for output file         */
  FILE *fp_report;		/* File pointer for report */
  FILE *fp_out_improv;  /*pour les resultats ameliorés*/
  int j, k, k1;
  POPULATION temp;		/* A temporary pointer of population    */

			/*---------------------------*/
  /* Program starts here :     */
			/*---------------------------*/
  printf
    ("**********************************************************************\n");
  printf
    ("***             MULTI-OBJECTIVE OPTIMIZATION SOFTWARE              ***\n");
  printf
    ("***                                                                ***\n");
  printf
    ("***        Developed by : Kalyanmoy Deb and Mayank Goyal           ***\n");
  printf
    ("***           The Department of Mechanical Engineering             ***\n");
  printf
    ("***        Indian Institute of Technology, Kanpur - INDIA          ***\n");
  printf
    ("***................................................................***\n");
  printf
    ("***  This software gives a set of solutions to a multi-objective   ***\n");
  printf
    ("***  optimization problem.  The parameters can be represented as   ***\n");
  printf
    ("***  any of the following following type (or their combination) :  ***\n");
  printf
    ("***              o BINARY STRING TYPE                              ***\n");
  printf
    ("***              o INTEGER TYPE                                    ***\n");
  printf
    ("***              o ENUMERATED DATA TYPE                            ***\n");
  printf
    ("***              o REAL/CONTINUOUS TYPE                            ***\n");
  printf
    ("***                                                                ***\n");
  printf
    ("***  For Multiobjective optimization, two strateies are there :    ***\n");
  printf
    ("***              o Share on FITNESS SPACE                          ***\n");
  printf
    ("***              o Share on PARAMETER SPACE                        ***\n");
  printf
    ("***  Sigma-share value should be chosen accordingly.               ***\n");
  printf
    ("***                                                                ***\n");
  printf
    ("***  You can also assign importance of one fitness function over   ***\n");
  printf
    ("***  other by giving them weightages.                              ***\n");
  printf
    ("\n***  All rights reserved. Not to be used for commercial purposes.  ***\n");
  printf
    ("\n***  Please send bug information and your comments to              *** ");
  printf
    ("\n***    deb@ls11.informatik.uni-dortmund.de or deb@iitk.ernet.in    ***");
  printf
    ("\n**********************************************************************");

  input_parameters ();

  fp_out = fopen ("result.out", "w+");
  fp_report = fopen ("report", "w+");

  select_memory ();
  //  initreport(fp_out);
  initreport (fp_report);

  gen_no = 0;
  initialize ();
  //initialisation_aleatoire ();
  MakeFronts ();
  statistics (oldpop, gen_no);

  result (fp_out, gen_no);



  if (REPORT)
    report (fp_report, gen_no);
  printf ("\n =====================================");
  printf ("======================================== ");
  printf ("\n Please Wait ");
  int STOP = 0;
  // do{



  for (gen_no = 1; gen_no <= max_gen; gen_no++)
    {
      printf ("%d - ", gen_no);
      // if (gen_no % 60 == 0)
      //printf ("\n");
      fflush (stdout);

      generate_new_pop ();

      temp = oldpop;
      oldpop = newpop;
      newpop = temp;

      MakeFronts ();
      statistics (oldpop, gen_no);

      if (REPORT)
	report (fp_report, gen_no);

         if (gen_no == max_gen)
         {
			 result (fp_out, gen_no); // les solutions sans amelioration.
			 if(contrainte_connectivite==0){
				 // printf("\namelioer_solution\n");
				 amelioer_solution();
			 }
			 else{
				 				 // printf("\namelioer_solution_avec_contrainte_conn\n");

             amelioer_solution_avec_contrainte_conn();
			 }

    fp_out_improv = fopen ("result-improved.out", "w+");
	   result (fp_out_improv, gen_no);
    report (fp_out_improv,gen_no);

         }

    };				/* One GA run is over  */

  //printf ("\n");
  //  }while(STOP==0);

  printf
    ("\n =============================================================================\n");
  printf (" Max couvrage de 1_sensors: %lf \n", MAX_COUV_1);
  printf (" Max couvrage de 2_sensors: %lf \n", MAX_COUV_2);
  printf (" Max couvrage de 3_sensors: %lf \n", MAX_COUV_3);
  printf (" Max couvrage de 4_sensors: %lf \n", MAX_COUV_4);
  printf (" Max couvrage de 5_sensors: %lf \n", MAX_COUV_5);
  printf (" Max couvrage de 6_sensors: %lf \n", MAX_COUV_6);
  printf (" Max couvrage de 7_sensors: %lf \n", MAX_COUV_7);
  printf (" Max couvrage de 8_sensors: %lf \n", MAX_COUV_8);
  printf (" Max couvrage de 9_sensors: %lf \n", MAX_COUV_9);
  printf (" Max couvrage de 10_sensors: %lf \n", MAX_COUV_10);
  printf (" Max couvrage de 11_sensors: %lf \n", MAX_COUV_11);
  printf (" Max couvrage de 12_sensors: %lf \n", MAX_COUV_12);
  printf (" Max couvrage de 13_sensors: %lf \n", MAX_COUV_13);
  printf (" Max couvrage de 14_sensors: %lf \n", MAX_COUV_14);
  printf (" Max couvrage de 15_sensors: %lf \n", MAX_COUV_15);
  printf (" Max couvrage de 16_sensors: %lf \n", MAX_COUV_16);
  printf (" Max couvrage de 17_sensors: %lf \n", MAX_COUV_17);
  printf (" Max couvrage de 18_sensors: %lf \n", MAX_COUV_18);
  printf (" Max couvrage de 19_sensors: %lf \n", MAX_COUV_19);
  printf (" Max couvrage de 20_sensors: %lf \n", MAX_COUV_20);
  printf (" Max couvrage de 21_sensors: %lf \n", MAX_COUV_21);
  printf (" Max couvrage de 22_sensors: %lf \n", MAX_COUV_22);
  printf (" Max couvrage de 23_sensors: %lf \n", MAX_COUV_23);
  printf (" Max couvrage de 24_sensors: %lf \n", MAX_COUV_24);
  printf (" Max couvrage de 25_sensors: %lf \n", MAX_COUV_25);
  printf (" Max couvrage de 26_sensors: %lf \n", MAX_COUV_26);
  printf (" Max couvrage de 27_sensors: %lf \n", MAX_COUV_27);
  printf (" Max couvrage de 28_sensors: %lf \n", MAX_COUV_28);
  printf (" Max couvrage de 29_sensors: %lf \n", MAX_COUV_29);
  printf (" Max couvrage de 30_sensors: %lf \n", MAX_COUV_30);
  printf (" Max couvrage de 31_sensors: %lf \n", MAX_COUV_31);
  printf (" Max couvrage de 32_sensors: %lf \n", MAX_COUV_32);
  printf (" Max couvrage de 33_sensors: %lf \n", MAX_COUV_33);
  printf (" Max couvrage de 34_sensors: %lf \n", MAX_COUV_34);
  printf (" Max couvrage de 35_sensors: %lf \n", MAX_COUV_35);
  printf (" Max couvrage de 36_sensors: %lf \n", MAX_COUV_36);
  printf (" Max couvrage de 37_sensors: %lf \n", MAX_COUV_37);
  printf (" Max couvrage de 38_sensors: %lf \n", MAX_COUV_38);
  printf (" Max couvrage de 39_sensors: %lf \n", MAX_COUV_39);
  printf (" Max couvrage de 40_sensors: %lf \n", MAX_COUV_40);
  printf (" Max couvrage de 41_sensors: %lf \n", MAX_COUV_41);
  printf (" Max couvrage de 42_sensors: %lf \n", MAX_COUV_42);
  printf (" Max couvrage de 43_sensors: %lf \n", MAX_COUV_43);
  printf (" Max couvrage de 44_sensors: %lf \n", MAX_COUV_44);
  printf (" Max couvrage de 45_sensors: %lf \n", MAX_COUV_45);
  printf (" Max couvrage de 46_sensors: %lf \n", MAX_COUV_46);
  printf (" Max couvrage de 47_sensors: %lf \n", MAX_COUV_47);
  printf (" Max couvrage de 48_sensors: %lf \n", MAX_COUV_48);
  printf (" Max couvrage de 49_sensors: %lf \n", MAX_COUV_49);
  printf (" Max couvrage de 50_sensors: %lf \n", MAX_COUV_50);
  printf (" Max couvrage de 51_sensors: %lf \n", MAX_COUV_51);
  printf (" Max couvrage de 52_sensors: %lf \n", MAX_COUV_52);

  printf (" Min sensors %d , gen_no %d", Min_sensor, gen_Min_sensor);



  //free_all();

  fclose (fp_out);
  fclose (fp_out_improv);
  fclose (fp_report);
  app_closure ();
  printf ("\n Results are stored in file 'result.out' ");
  puts ("\n O.K Good bye !!!");
}

		/**************** End of Main Program ***************************/

		/*-------------------------------------------------------  */
		/* random.c - contains random number generator and related */
		/* utilities,                                              */
		/* Source : sga.c  (c) E.Goldberg 1986
		   /*-------------------------------------------------------  */

		/* variables are declared static so that they cannot       */
		/* conflict with names of other global variables in other  */
		/* files.  See K&R, p 80, for scope of static              */

static double oldrand[55];	/* Array of 55 random numbers */
static int jrand;		/* current random number */
static double rndx2;		/* used with random normal deviate */
static int rndcalcflag;		/* used with random normal deviate */

int
small (float number)
{
  if (fabs (number) <= EPSILON)
    return TRUE;
  else
    return FALSE;
}

initrandomnormaldeviate ()
  /* initialization routine for randomnormaldeviate */
{
  rndcalcflag = 1;
}

double
noise (mu, sigma)
		/* normal noise with specified mean & std dev: mu & sigma */
     double mu, sigma;
{
  double randomnormaldeviate ();

  return ((randomnormaldeviate () * sigma) + mu);
}

double
randomnormaldeviate ()
		/* random normal deviate after ACM algorithm 267 / Box-Muller Method */
{
  double sqrt (), log (), sin (), cos ();
  float randomperc ();
  double t, rndx1;

  if (rndcalcflag)
    {
      rndx1 = sqrt (-2.0 * log ((double) randomperc ()));
      t = 6.2831853072 * (double) randomperc ();
      rndx2 = sin (t);
      rndcalcflag = 0;
      return (rndx1 * cos (t));
    }
  else
    {
      rndcalcflag = 1;
      return (rndx2);
    }
}

advance_random ()
  /* Create next batch of 55 random numbers */
{
  int j1;
  double new_random;

  for (j1 = 0; j1 < 24; j1++)
    {
      new_random = oldrand[j1] - oldrand[j1 + 31];
      if (new_random < 0.0)
	new_random = new_random + 1.0;
      oldrand[j1] = new_random;
    }
  for (j1 = 24; j1 < 55; j1++)
    {
      new_random = oldrand[j1] - oldrand[j1 - 24];
      if (new_random < 0.0)
	new_random = new_random + 1.0;
      oldrand[j1] = new_random;
    }
}

int
flip (prob)
		/* Flip a biased coin - true if heads */
     float prob;
{
  float randomperc ();

  if (randomperc () <= prob)
    return (1);
  else
    return (0);
}

randomize ()
  /* Get seed number for random and start it up */
{
  int j1;

  for (j1 = 0; j1 <= 54; j1++)
    oldrand[j1] = 0.0;
  jrand = 0;

  warmup_random (seed);
  initrandomnormaldeviate ();
}

float
randomperc ()
		/* Fetch a single random number between 0.0 and 1.0 -  */
		/* Subtractive Method . See Knuth, D. (1969), v. 2 for */
		/* details.Name changed from random() to avoid library */
		/* conflicts on some machines                          */
{
  jrand++;
  if (jrand >= 55)
    {
      jrand = 1;
      advance_random ();
    }
  return ((float) oldrand[jrand]);
}

int
rnd (low, high)
		/* Pick a random integer between low and high */
     int low, high;
{
  int i;
  float randomperc ();

  if (low >= high)
    i = low;
  else
    {
      i = (randomperc () * (high - low + 1)) + low;
      if (i > high)
	i = high;
    }
  return (i);
}

float
rndreal (lo, hi)
		/* real random number between specified limits */
     float lo, hi;
{
  return ((randomperc () * (hi - lo)) + lo);
}

warmup_random (random_seed)
  /* Get random off and running */
     float random_seed;
{
  int j1, ii;
  double new_random, prev_random;

  oldrand[54] = random_seed;
  new_random = 0.000000001;
  prev_random = random_seed;
  for (j1 = 1; j1 <= 54; j1++)
    {
      ii = (21 * j1) % 54;
      oldrand[ii] = new_random;
      new_random = prev_random - new_random;
      if (new_random < 0.0)
	new_random = new_random + 1.0;
      prev_random = oldrand[ii];
    }

  advance_random ();
  advance_random ();
  advance_random ();

  jrand = 0;
}

		/*----------------------------------------------------------*/
		/* Files for tournament selection :                         */
		/* Source : sga.c (c) E.Goldberg                            */
		/*----------------------------------------------------------*/

select_memory ()
{
  /* allocates auxiliary memory for stochastic remainder selection */

  unsigned nbytes;
  int j;

  choices = NULL;
  fraction = NULL;
  nbytes = pop_size * sizeof (int);
  if ((choices = (int *) malloc (nbytes)) == NULL)
    nomemory (stderr, "choices");
  nbytes = pop_size * sizeof (float);
  if ((fraction = (float *) malloc (nbytes)) == NULL)
    nomemory (stderr, "fraction");
}

select_free ()
{
  /* frees auxiliary memory for stochastic remainder selection */
  choices = NULL;
  fraction = NULL;
  free (choices);
  free (fraction);
}

preselect ()
  /* preselection for stochastic remainder method */
{
  int j, jassign, k;
  float expected;
  int flip ();

  if (dum_avg == 0)
    {
      for (j = 0; j < pop_size; j++)
	choices[j] = j;
    }
  else
    {
      j = 0;
      k = 0;
      /* Assign whole numbers */
      do
	{
	  expected = (float) ((oldpop[j].dumfitness) / dum_avg);
	  jassign = (int) expected;
	  /* note that expected is automatically truncated */
	  fraction[j] = expected - (float) jassign;

	  while (jassign > 0)
	    {
	      jassign--;
	      choices[k] = j;
	      k++;
	    }
	  j++;
	}
      while (j < pop_size);

      j = 0;
      /* Assign fractional parts */
      while (k < pop_size)
	{
	  if (j >= pop_size)
	    j = 0;
	  if (fraction[j] > 0.0)
	    {
	      /* A winner if true */
	      if (flip (fraction[j]))
		{
		  choices[k] = j;
		  fraction[j] = fraction[j] - 1.0;
		  k++;
		}
	    }
	  j++;
	}
    }
  nremain = pop_size - 1;

}

int
select ()
		/* selection using remainder method */
{
  int jpick, slect;
  int rnd ();
  //printf ("\nnremain=%d  \n", nremain);

  jpick = rnd (0, nremain);
  //printf ("\njpick=%d  \n", jpick);

  slect = choices[jpick];
  choices[jpick] = choices[nremain];
  //printf("\njpick=%d   choices[jpick]=%d  nremain=%d  \n",jpick,choices[jpick],nremain);

  // nremain--;
  return (slect);
}


reset1 ()
  /* Name changed from reset because of clash with lib. function - RBA */
  /* Shuffles the tourneylist at random */
{
  int i, rand1, rand2, temp_site;

  for (i = 0; i < pop_size; i++)
    tourneylist[i] = i;

  for (i = 0; i < pop_size; i++)
    {
      rand1 = rnd (0, pop_size - 1);
      rand2 = rnd (0, pop_size - 1);
      temp_site = tourneylist[rand1];
      tourneylist[rand1] = tourneylist[rand2];
      tourneylist[rand2] = temp_site;
    }
}

		/******************* APPLICATION ORIENTED ROUTINES ***************/
		/**** Change these routines for your particular application ******/

input_app_parameters ()
  /* Input your application dependent parameters here and put the
     output in global variables */
{
}

app_computation ()
  /* this routine should contain any application-dependent computations */
  /* that should be performed before each GA cycle.
     called by generate_new_pop    */
{
}

app_free ()
  /* application dependent free() calls, called by free_all() */
{
}

app_initialize ()
  /* application dependent initialization routine called by intialize() */
{
}


app_initreport ()
  /* Application-dependent initial report called by initreport() */
{
}

app_report ()
  /* Application-dependent report, called by report() */
{
}


app_statistics ()
  /* Application-dependent statistics calculations called by statistics() */
{
}

app_closure ()
  /* Application-dependent work which should be done before closure of
     the main program. called by main() */
{
}

		/*====================================================================
		  OBJECTIVE FUNCTION : Change it for different applications

		  Given a sample application where the two objective functions are :
		  f1(x) = x*x;
		  f2(x) = (x-2)*(x-2)  and the aim is to minimize both of them.

		  NORMALIZE your fitness functions before use. (Divide them by their
		  maximum possible values)

		  The code is designed for minimizing the fitness functions.
		  To maximize a function, either use
		  o 1/(1+f(x)) or
		  o -f(x)  instead of f(x).
		  ===================================================================*/
// pour calculer la seuil de couverture (Rs) et connectivité (Rc)
void set_seuil_couv_et_conn(){
    SEUIL_COUVERTURE=Rs/(Rs*2);
	SEUIL_CONNECTIVITE=Rc/(Rc+1);
}

void get_position_capteur(int T[]){
    int p=0;
    // initialiser
        for(int i=0; i<longeur*largeur;i++){
            position_capt[i]=0;
    }
    for(int i=0; i<longeur*largeur;i++){
        if(T[i]==1){
            position_capt[p]=i+1; p++;
        }
    }
    TAILLE_PC=p;
}

/*
void get_position_capteurs (chrom)
     unsigned *chrom;
{
  int j, k, stop, count = 0;
  unsigned mask = 1, tmp;
  int temp[longeur * largeur];
 int chromosome[3000]; taille_pc=0;
  for (j = 0; j < longeur * largeur; j++)	//normalement on remplace longeur*largeur par TAILLE_CHROMOSOME
  {temp[j] = 0;chromosome[j]=0; }

  for (k = 0; k < chromsize; k++)
    {
      tmp = chrom[k];
      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      for (j = 0; j < stop; j++)
	{
	  if (tmp & mask)
	    {
	      temp[j + count * UINTSIZE] = 1;

	    }
	  else
	    {
	      temp[j + count * UINTSIZE] = 0;
	    }
	  tmp = tmp >> 1;
	}
      count++;
    }










  //remplir le chromosome

  printf("\n");
  for (int i = 0; i < longeur * largeur; i++)
    {
      chromosome[i] = temp[longeur * largeur - 1 - i];
	  	 // if(chromosome[i]==1){
	  // position_capt[taille_pc] = i+1;

	  // taille_pc++;
	 // }

printf("%d",chromosome[i]);
    }
  printf("\n");

    for(int i=0;i<taille_pc;i++)
	printf("%d - ",position_capt[i]);
    printf("\n");





}

*/













int
IntRand (int lower, int upper)
{
  //float x=(float)rand()/((float)RAND_MAX/a)
  int num = (rand () % (upper - lower + 1)) + lower;
  return num;

}


void
ecrire_fichier (float T[], int taille)
{

  FILE *fichier = NULL;
  fichier = fopen ("test.txt", "a");

  if (fichier != NULL)
    {

      for (int i = 0; i < taille; i++)
	fprintf (fichier, "%f\n", T[i]);
      fclose (fichier);
    }

}

		// Conversion C  l'unitC).
int
conver_unit (float x)
{
  int a = (int) x;
  float b = (float) a;
  float c = b + 0.5;
  if (x < c)
    return a;
  else
    return a + 1;
}

int
taille_chrom ()
{
  return (((longeur / dL) * dL) * ((largeur / dl) * dl)) / (dL * dl);
}

void
get_coordonnees (int position, int *ligne, int *colonne)
{
  //int longeur=28, largeur=26, x;
  //int dL=5, dl=5;
  int x;
  *ligne = ((((position - 1) / (longeur / dL)) + 1) * dl) - 1;

  x = (position % (longeur / dL));
  if (x == 0)
    *colonne = ((longeur / dL) * dL) - 1;
  else
    *colonne = ((position % (longeur / dL)) * dL) - 1;
}

		// convertir un tableua C  une matrice
void
tab_to_matrix (int chromosome[700])
{

  int ligne = -1, colonne = -1;
  //initialisation:
  for (int i = 0; i < largeur; i++)
    {
      for (int j = 0; j < longeur; j++)
	{
	  sensor[i][j] = 0;
	}
    }

  for (int position = 0; position < TAILLE_CHROMOSOME; position++)
    {
      get_coordonnees (position + 1, &ligne, &colonne);
      sensor[ligne][colonne] = chromosome[position];
	  // printf("%d",chromosome[position]);

      //printf("%d",sensor[ligne][colonne]);

    }
	     // printf("\n");

  /*
     for(int i=0; i<largeur;i++){
     printf("\n");
     for(int j=0; j<longeur;j++){
     printf("%d",sensor[i][j]);}
     }
   */
}


void
facteur_droit (float i, float j, float k, float l, float *a, float *b)
{

  float A = (l - j) / (k - i);
  float B = j - (A * i);
  // printf(" a est %f    et  b est %f \n",A,B);
  *a = A;
  *b = B;

}


		// calculer le nombre de sensor.

int
number_of_sensors (chrom)
     unsigned *chrom;
{
  int j, k, stop, count = 0, num_sensor = 0,taille_pc=0;
  unsigned mask = 1, tmp;
  int temp[longeur * largeur];



  for (j = 0; j < longeur * largeur; j++)	//normalement on remplace longeur*largeur par TAILLE_CHROMOSOME
    temp[j] = 0;
  for (k = 0; k < chromsize; k++)
    {
      tmp = chrom[k];
      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      for (j = 0; j < stop; j++)
	{
	  if (tmp & mask)
	    {
	      temp[j + count * UINTSIZE] = 1;
	      num_sensor++;
	    }
	  else
	    {
	      temp[j + count * UINTSIZE] = 0;
	    }
	  tmp = tmp >> 1;
	}
      count++;
    }



  //remplir le chromosome
  int chromosome[3000];
    // printf("\n");
  for (int i = 0; i < longeur * largeur; i++)
    {
      chromosome[i] = temp[longeur * largeur - 1 - i];
	  	 if(chromosome[i]==1){
			 // printf("%d - ", i+1);

	  position_capt[taille_pc] = i+1;

	  taille_pc++;
	 }
// printf("%d",chromosome[i]);
    }
  // printf("\n");

// for(int j=0;j<taille_pc;j++)
  // printf("%d - ",position_capt[j]);

  // printf("\n");
  // for (int i = 0; i < longeur * largeur; i++)
	    // printf("%d",chromosome[i]);
  // printf("\n");

  // printf("\n-->%d",taille_pc);
TAILLE_PC=taille_pc;

  tab_to_matrix (chromosome);

  return num_sensor;
}

float
attenuation_signal (int i, int j, int k, int l)
{
  float a = 0.0, b = 0.0, y, x, R, Attunaution = 0;
  int X, Y, r1, r2;
  if (k == i)
    {
      // printf(" les obstacles verticales:\n");
      if (j > l)
	{
	  r1 = j;
	  j = l;
	  l = r1;
	  r2 = i;
	  i = k;
	  k = r2;
	}
      for (int v = j + 1; v < l + 1; v++)
	{
	  X = i;
	  Y = v;
	  //printf(" x = %d , y = %d \n",X,Y);
	  Attunaution = Attunaution + (float) obstacles_verti_sig[X][Y];
	}
    }
  else
    {
      facteur_droit (i, j, k, l, &a, &b);
      // printf(" les obstacles verticales:\n");
      if (j > l)
	{
	  r1 = j;
	  j = l;
	  l = r1;
	  r2 = i;
	  i = k;
	  k = r2;
	}
      for (int v = j + 1; v < l + 1; v++)
	{
	  y = v - 0.5;
	  x = (y - b) / a;
	  X = conver_unit (x);
	  Y = conver_unit (y);
	  //   printf(" x = %d , y = %d \n",X,Y);

	  Attunaution = Attunaution + (float) obstacles_verti_sig[X][Y];
	}

      //printf(" les obstacles horizontale:\n");
      if (i > k)
	{
	  r1 = j;
	  j = l;
	  l = r1;
	  r2 = i;
	  i = k;
	  k = r2;
	}
      for (int u = i + 1; u < k + 1; u++)
	{
	  x = u - 0.5;
	  y = a * x + b;
	  // changement les valeur car la matrice est inversC):
	  R = x;
	  x = y;
	  y = R;
	  X = conver_unit (x);
	  Y = conver_unit (y);
	  // printf(" x = %d , y = %d \n",X,Y);
	  Attunaution = Attunaution + (float) obstacles_horis_sig[X][Y];
	}
    }
  return (PL0 + 20*log10(DISTANCE_(i,j,k,l)) + Attunaution );
}


float
attenuation (int i, int j, int k, int l)
{
  float a = 0.0, b = 0.0, y, x, R, Attunaution = 0;
  int X, Y, r1, r2;
  if (k == i)
    {
      // printf(" les obstacles verticales:\n");
      if (j > l)
	{
	  r1 = j;
	  j = l;
	  l = r1;
	  r2 = i;
	  i = k;
	  k = r2;
	}
      for (int v = j + 1; v < l + 1; v++)
	{
	  X = i;
	  Y = v;
	  //printf(" x = %d , y = %d \n",X,Y);
	  Attunaution = Attunaution + (float) obstacles_verti[X][Y];
	}
    }
  else
    {
      facteur_droit (i, j, k, l, &a, &b);
      // printf(" les obstacles verticales:\n");
      if (j > l)
	{
	  r1 = j;
	  j = l;
	  l = r1;
	  r2 = i;
	  i = k;
	  k = r2;
	}
      for (int v = j + 1; v < l + 1; v++)
	{
	  y = v - 0.5;
	  x = (y - b) / a;
	  X = conver_unit (x);
	  Y = conver_unit (y);
	  //   printf(" x = %d , y = %d \n",X,Y);

	  Attunaution = Attunaution + (float) obstacles_verti[X][Y];
	}

      //printf(" les obstacles horizontale:\n");
      if (i > k)
	{
	  r1 = j;
	  j = l;
	  l = r1;
	  r2 = i;
	  i = k;
	  k = r2;
	}
      for (int u = i + 1; u < k + 1; u++)
	{
	  x = u - 0.5;
	  y = a * x + b;
	  // changement les valeur car la matrice est inversC):
	  R = x;
	  x = y;
	  y = R;
	  X = conver_unit (x);
	  Y = conver_unit (y);
	  // printf(" x = %d , y = %d \n",X,Y);
	  Attunaution = Attunaution + (float) obstacles_horis[X][Y];
	}
    }
  return Attunaution;
}




		// calculer la distence entre deux points.
double
DISTANCE_ (int i, int j, int k, int l)
{
  return sqrt (pow ((i - k), 2) + pow ((j - l), 2));
}

double
couvrage ()
{
  int num_cell_cover = 0, R =
    (int) round (Rs), k, l, k_dep, l_dep, k_stop, l_stop;
  double taux_couv = 0.0, S = 0, somme_couv = 0;
  double couvrage[150][150];
  // initialisation
  for (int i = 0; i < largeur; i++)
    {
      for (int j = 0; j < longeur; j++)
	{
	  couvrage[i][j] = 0;
	}
    }

  /*
     printf("\n-------------");

     for (int i = 0; i < largeur; i++)
     {
     printf("\n");
     for (int j = 0; j < longeur; j++)
     {
     printf("%d",sensor[i][j]);
     }
     }
   */


  // calculer_couverture;
  // parcourir les cell
  for (int i = 0; i < largeur; i++)
    {
      for (int j = 0; j < longeur; j++)
	{
	  // rechercher les capteurs
	  // trouver les indices des depart, pour rechercher justes cell voisin.
	  //indices de depart
	  if (i - R < 0)
	    k_dep = 0;
	  else
	    k_dep = i - R;
	  if (j - R < 0)
	    l_dep = 0;
	  else
	    l_dep = j - R;
	  // indices d'arrive
	  if (i + R > largeur - 1)
	    {
	      k_stop = largeur - 1;
	    }
	  else
	    k_stop = i + R;
	  if (j + R > longeur - 1)
	    l_stop = longeur - 1;
	  else
	    l_stop = j + R;


	  for (k = k_dep; k <= k_stop; k++)
	    {
	      for (l = l_dep; l <= l_stop; l++)
		{


		  if (sensor[k][l] == 1)
		    {
		      S = 0;
		      S = Rs/ (DISTANCE_(i, j, k, l) * exp(attenuation (i, j, k, l)) + Rs) ;
		      if (S > couvrage[i][j])
			{
			  couvrage[i][j] = S;

			}
		    }

		}

	    }
	}
    }


  // cette methode calcule le taux de couverture, ou chaque cout de cellule depace ou egale le seuil signefie que cette cellule est couvrC).
  // C  la fin on calcule le taux de couveture a traver la somme des cellules couvrC).

  for (int i = 0; i < largeur; i++)
    {
      for (int j = 0; j < longeur; j++)
	{
	  //somme_couv = somme_couv+couvrage[i][j];
	  if (couvrage[i][j] >= SEUIL_COUVERTURE)
	    {
	      num_cell_cover++;
	    }
	}
    }
  taux_couv = (double) (num_cell_cover * 100) / (double) (largeur * longeur);
  //printf("-- %lf -- %lf ---\n",Rs *(n*m),somme_couv );
  //printf("le taux de couvrage est: %lf \n",taux_couv );



  /*
     // cette methode calcule la somme de couvrage de toutes les cellules:
     for (int i = 0; i < largeur; i++)
     {
     for (int j = 0; j < longeur; j++)
     {
     somme_couv = somme_couv+couvrage[i][j];

     }
     }
   */

  return taux_couv;

}



void traverse(int u, int visited[]) {

   visited[u] = 1; //mark v as visited
   for(int v = 0; v<TAILLE_PC; v++) {

      if(graph[u][v]) {
         if(visited[v]==0)
            traverse(v, visited);
      }
   }
}

int isConnected() {


   int vis[TAILLE_PC];
   //for all vertex u as start point, check whether all nodes are visible or not
   for(int u=0; u < TAILLE_PC; u++) {
      for(int i = 0; i<TAILLE_PC; i++)
         vis[i] = 0; //initialize as no node is visited

         traverse(u, vis);

      for(int i = 0; i<TAILLE_PC; i++) {
         if(vis[i]==0) //if there is a node, not visited by traversal, graph is not connected
            return 0;
      }
   }
   return 1;
}





void
connective_connexite (float *taux_connectiv, int *connexite)
{
  int nombre_N_connete = 0, nombre_liaison, x_i, y_i, x_j, y_j;
  double s;

// initialiser le graphe des noeuds:
for(int i=0; i<TAILLE_PC;i++)
	for(int j=0; j<TAILLE_PC;j++)
       graph[i][j]=0;

  if (TAILLE_PC != 0)
    {
     // printf ("\nla taille est: %d \n",TAILLE_PC);
      //parcourir le position_capt
      for (int i = 0; i < TAILLE_PC; i++)
	{
	  nombre_liaison = 0;
	  // printf ("%d -> ", position_capt[i]);

	  //calculer pour chaque noeud le nombre de liaison:
	  for (int j = 0; j < TAILLE_PC; j++)
	    {

	      if (i != j)
		{
		  get_coordonnees (position_capt[i], &x_i, &y_i);
		  get_coordonnees (position_capt[j], &x_j, &y_j);

		  if (power_recev<=power_trans - attenuation_signal(x_i,y_i,x_j,y_j)){
		    nombre_liaison++;
			graph[i][j]=1;
		  }
		}
	    }
	  // printf ("%d  | ", nombre_liaison);

	  if (nombre_liaison >= contrainte_connectivite)
	    nombre_N_connete++;
	}

	// calculer le taux de connectivité
      *taux_connectiv = (float) (nombre_N_connete * 100) / (float) TAILLE_PC;


    // verifier la connexité des noeuds

    *connexite=isConnected();
     // printf ("\n");


		// for(int i=0; i<TAILLE_PC;i++)
	// {
		// printf ("\n{");
	// for(int j=0; j<TAILLE_PC;j++)
       // printf ("%d ,",graph[i][j]);
   		// printf ("},");

	// }



/*
if(connexite==1)
{printf("\nle graphe est connexe");}
else {printf("\nle graphe n est pas connexe");}
*/

    }
}

void MAJ_meilleur_couvr(){

	if (NUM_SENSORS == 1 && COUVRAGE > MAX_COUV_1)
    MAX_COUV_1 = COUVRAGE;
  else if (NUM_SENSORS == 2 && COUVRAGE > MAX_COUV_2)
    MAX_COUV_2 = COUVRAGE;
  else if (NUM_SENSORS == 3 && COUVRAGE > MAX_COUV_3)
    MAX_COUV_3 = COUVRAGE;
  else if (NUM_SENSORS == 4 && COUVRAGE > MAX_COUV_4)
    MAX_COUV_4 = COUVRAGE;
  else if (NUM_SENSORS == 5 && COUVRAGE > MAX_COUV_5)
    MAX_COUV_5 = COUVRAGE;
  else if (NUM_SENSORS == 6 && COUVRAGE > MAX_COUV_6)
    MAX_COUV_6 = COUVRAGE;
  else if (NUM_SENSORS == 7 && COUVRAGE > MAX_COUV_7)
    MAX_COUV_7 = COUVRAGE;
  else if (NUM_SENSORS == 8 && COUVRAGE > MAX_COUV_8)
    MAX_COUV_8 = COUVRAGE;
  else if (NUM_SENSORS == 9 && COUVRAGE > MAX_COUV_9)
    MAX_COUV_9 = COUVRAGE;
  else if (NUM_SENSORS == 10 && COUVRAGE > MAX_COUV_10)
    MAX_COUV_10 = COUVRAGE;
  else if (NUM_SENSORS == 11 && COUVRAGE > MAX_COUV_11)
    MAX_COUV_11 = COUVRAGE;
  else if (NUM_SENSORS == 12 && COUVRAGE > MAX_COUV_12)
    MAX_COUV_12 = COUVRAGE;
  else if (NUM_SENSORS == 13 && COUVRAGE > MAX_COUV_13)
    MAX_COUV_13 = COUVRAGE;
  else if (NUM_SENSORS == 14 && COUVRAGE > MAX_COUV_14)
    MAX_COUV_14 = COUVRAGE;
  else if (NUM_SENSORS == 15 && COUVRAGE > MAX_COUV_15)
    MAX_COUV_15 = COUVRAGE;
  else if (NUM_SENSORS == 16 && COUVRAGE > MAX_COUV_16)
    MAX_COUV_16 = COUVRAGE;
  else if (NUM_SENSORS == 17 && COUVRAGE > MAX_COUV_17)
    MAX_COUV_17 = COUVRAGE;
  else if (NUM_SENSORS == 18 && COUVRAGE > MAX_COUV_18)
    MAX_COUV_18 = COUVRAGE;
  else if (NUM_SENSORS == 19 && COUVRAGE > MAX_COUV_19)
    MAX_COUV_19 = COUVRAGE;
  else if (NUM_SENSORS == 20 && COUVRAGE > MAX_COUV_20)
    MAX_COUV_20 = COUVRAGE;
  else if (NUM_SENSORS == 21 && COUVRAGE > MAX_COUV_21)
    MAX_COUV_21 = COUVRAGE;
  else if (NUM_SENSORS == 22 && COUVRAGE > MAX_COUV_22)
    MAX_COUV_22 = COUVRAGE;
  else if (NUM_SENSORS == 23 && COUVRAGE > MAX_COUV_23)
    MAX_COUV_23 = COUVRAGE;
  else if (NUM_SENSORS == 24 && COUVRAGE > MAX_COUV_24)
    MAX_COUV_24 = COUVRAGE;
  else if (NUM_SENSORS == 25 && COUVRAGE > MAX_COUV_25)
    MAX_COUV_25 = COUVRAGE;
  else if (NUM_SENSORS == 26 && COUVRAGE > MAX_COUV_26)
    MAX_COUV_26 = COUVRAGE;
  else if (NUM_SENSORS == 27 && COUVRAGE > MAX_COUV_27)
    MAX_COUV_27 = COUVRAGE;
  else if (NUM_SENSORS == 28 && COUVRAGE > MAX_COUV_28)
    MAX_COUV_28 = COUVRAGE;
    else if (NUM_SENSORS == 29 && COUVRAGE > MAX_COUV_29)
    MAX_COUV_29 = COUVRAGE;
    else if (NUM_SENSORS == 30 && COUVRAGE > MAX_COUV_30)
    MAX_COUV_30 = COUVRAGE;
    else if (NUM_SENSORS == 31 && COUVRAGE > MAX_COUV_31)
    MAX_COUV_31 = COUVRAGE;
    else if (NUM_SENSORS == 32 && COUVRAGE > MAX_COUV_32)
    MAX_COUV_32 = COUVRAGE;
    else if (NUM_SENSORS == 33 && COUVRAGE > MAX_COUV_33)
    MAX_COUV_33 = COUVRAGE;
    else if (NUM_SENSORS == 34 && COUVRAGE > MAX_COUV_34)
    MAX_COUV_34 = COUVRAGE;
    else if (NUM_SENSORS == 35 && COUVRAGE > MAX_COUV_35)
    MAX_COUV_35 = COUVRAGE;
    else if (NUM_SENSORS == 36 && COUVRAGE > MAX_COUV_36)
    MAX_COUV_36 = COUVRAGE;
    else if (NUM_SENSORS == 37 && COUVRAGE > MAX_COUV_37)
    MAX_COUV_37 = COUVRAGE;
    else if (NUM_SENSORS == 38 && COUVRAGE > MAX_COUV_38)
    MAX_COUV_38 = COUVRAGE;
    else if (NUM_SENSORS == 39 && COUVRAGE > MAX_COUV_39)
    MAX_COUV_39 = COUVRAGE;
    else if (NUM_SENSORS == 40 && COUVRAGE > MAX_COUV_40)
    MAX_COUV_40 = COUVRAGE;
    else if (NUM_SENSORS == 41 && COUVRAGE > MAX_COUV_41)
    MAX_COUV_41 = COUVRAGE;
    else if (NUM_SENSORS == 42 && COUVRAGE > MAX_COUV_42)
    MAX_COUV_42 = COUVRAGE;
    else if (NUM_SENSORS == 43 && COUVRAGE > MAX_COUV_43)
    MAX_COUV_43 = COUVRAGE;
    else if (NUM_SENSORS == 44 && COUVRAGE > MAX_COUV_44)
    MAX_COUV_44 = COUVRAGE;
    else if (NUM_SENSORS == 45 && COUVRAGE > MAX_COUV_45)
    MAX_COUV_45 = COUVRAGE;
    else if (NUM_SENSORS == 46 && COUVRAGE > MAX_COUV_46)
    MAX_COUV_46 = COUVRAGE;
    else if (NUM_SENSORS == 47 && COUVRAGE > MAX_COUV_47)
    MAX_COUV_47 = COUVRAGE;
    else if (NUM_SENSORS == 48 && COUVRAGE > MAX_COUV_48)
    MAX_COUV_48 = COUVRAGE;
    else if (NUM_SENSORS == 49 && COUVRAGE > MAX_COUV_49)
    MAX_COUV_49 = COUVRAGE;
    else if (NUM_SENSORS == 50 && COUVRAGE > MAX_COUV_50)
    MAX_COUV_50 = COUVRAGE;
    else if (NUM_SENSORS == 51 && COUVRAGE > MAX_COUV_51)
    MAX_COUV_51 = COUVRAGE;
    else if (NUM_SENSORS == 52 && COUVRAGE > MAX_COUV_52)
    MAX_COUV_52 = COUVRAGE;
}


int get_position(int i,int j)
{
    int  x=i+1, y=j+1;

    return (longeur*(x-1) +y)-1;
}


// cette fonction ameliore les solutions generé par l'algo NSGA, sans prise en consediration la connectivité et la connexité
void amelioer_solution()
{


	int chromosome[1000], temp[1000],p,valeur,connexite;
	int R=(int)round(Rs),k_dep,l_dep,k_stop,l_stop,repeter,rep;
    double couv,couv_t,couv_Max=-1;
	unsigned chrom;
	float taux_conn;

  int stop, count = 0,coun=0;
  unsigned mask = 1, tmp;
  int temp1[longeur * largeur];



for(int b=0; b<pop_size; b++){


	        // converter un chrom to tableau chromosome[ ]:
	  count = 0;
  for (int k = 0; k < chromsize; k++)
    {
              tmp = oldpop[b].chrom[k];
      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      for (int j = 0; j < stop; j++)
	{
	  if (tmp & mask)
	    {
	      /*fprintf(fp,"1"); */
	      temp1[j + count * UINTSIZE] = 1;
	    }
	  else
	    {
	      /*fprintf(fp,"0"); */
	      temp1[j + count * UINTSIZE] = 0;
	    }
	  tmp = tmp >> 1;
	}
      count++;
    }


 coun = 0;

      for (int k = longeur*largeur- 1; k >= 0; k--)
	{
		chromosome[coun]=temp1[k]; coun++;
	}



 //1)  on verifier si il existe des capteurs supplementaires.

  tab_to_matrix(chromosome);
    couv=couvrage();

// recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        temp[h]=chromosome[h];
    }



    for(int i=0; i<longeur*largeur; i++)
    {
        if(temp[i]==1)
        {

            temp[i]=0;
            tab_to_matrix(temp);
            couv_t=couvrage();
            //affichage:
            // for(int i=0; i<longeur*largeur; i++)
            // printf("%d",temp[i]);
		    // printf("\n");


            // ces instructions sont pour la connectivité et la connexité:
			// get_position_capteur(temp);
		    // connective_connexite (&taux_conn, &connexite);
            // printf("\ntaux_conn=%f  -  connexite=%d ",taux_conn,connexite);
           // if(couv_t==couv   && taux_conn==100 && connexite==1)

			 if(couv_t==couv )

            {

// recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        chromosome[h]=temp[h];
    }
	i=0;
            }
            else
                // recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        temp[h]=chromosome[h];
    };
        }
    }

	        // for(int i=0; i<longeur*largeur; i++)
            // printf("%d",chromosome[i]);
		// printf("\n");



    // 2) on deplace les capteurs dans une zone (Rs*Rs) pour trouver un couverture mieux que l'anciene couverture:

    do{
    repeter=0;
    for(int i=0; i<largeur; i++)
    {
        for(int j=0; j<longeur; j++)
        {

// recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        temp[h]=chromosome[h];
    }

	tab_to_matrix(chromosome);
            couv=couvrage();

            if(sensor[i][j]==1)
            {
		// printf("\n(%d,%d)\n",i,j);

                //indices de depart
                if (i - R < 0)
                    k_dep = 0;
                else
                    k_dep = i - R;
                if (j - R < 0)
                    l_dep = 0;
                else
                    l_dep = j - R;
                // indices d'arrive
                if (i + R > largeur - 1)
                {
                    k_stop = largeur - 1;
                }
                else
                    k_stop = i + R;
                if (j + R > longeur - 1)
                    l_stop = longeur - 1;
                else
                    l_stop = j + R;

		// printf("\n %d %d %d %d \n",k_dep,l_dep,k_stop,l_stop);



                //-----------------------------------------//
                //supprimer le noeud:
                sensor[i][j]=0;
                p=get_position(i,j);
                temp[p]=0;
					        // for(int i=0; i<longeur*largeur; i++)
            // printf("%d",temp[i]);
		// printf("\n");


                for(int k=k_dep; k<=k_stop; k++)
                {
                    for(int l=l_dep; l<=l_stop; l++)
                    {
                        sensor[k][l]=1;
                        p=get_position(k,l);
                        temp[p]=1;
	                    tab_to_matrix(temp);  //<<<<<<<<<<
                        couv_t=couvrage();

            // ces instructions sont pour la connectivité et la connexité:
			// get_position_capteur(temp);
		    // connective_connexite (&taux_conn, &connexite);
            // printf("\ntaux_conn=%f  -  connexite=%d ",taux_conn,connexite);
            // if(couv_t>couv   && taux_conn==100 && connexite==1)

                       if(couv_t>couv)
                        {

                            // recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        chromosome[h]=temp[h];
    };
                            couv=couv_t;
							//supprimer le noeud pour la nouvelle deploiment:
					    sensor[k][l]=0;
                        p=get_position(k,l);
                        temp[p]=0;

                          repeter=1; // repete puisque il y a un changement dans le deploiment

                           // i=0;
                           // j=0;

                        }
                        else
                        {
                            sensor[k][l]=0;
                            temp[p]=0;
                        }


                    }
                }


            }

        }
    }

}while(repeter==1);






 // 3) remplir le chrom par le tableau chromosome:
  int m = longeur*largeur-1;
  for (int k = 0; k < chromsize; k++)
    {

      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      valeur = 0;
      for (int j = 0; j < stop; j++)
	{
	  if (chromosome[m] == 1)
	    {
	      valeur = valeur + pow (2, j);
	    }
	  m--;

	}
	oldpop[b].chrom[k] = valeur;

    }


// 4) calculer fitness 1 et fitness2 ,
      // pour decoder le chromosome à un valeur entier
	  decode_string (&(oldpop[b]));
	  update_x_BIN_ENUM (&(oldpop[b]));

	  objective (&(oldpop[b]));

      MAJ_meilleur_couvr();

      // les statistiques (comme Rank)
            MakeFronts ();
      statistics (oldpop, gen_no);




}







}




// cette fonction ameliore les solutions generé par l'algo NSGA, en prise en consediration la connectivité et la connexité
void amelioer_solution_avec_contrainte_conn()
{


	int chromosome[1000], temp[1000],p,valeur,connexite;
	int R=(int)round(Rs),k_dep,l_dep,k_stop,l_stop,repeter,rep;
    double couv,couv_t,couv_Max=-1;
	unsigned chrom;
	float taux_conn;

  int stop, count = 0,coun=0;
  unsigned mask = 1, tmp;
  int temp1[longeur * largeur];



for(int b=0; b<pop_size; b++){


	        // converter un chrom to tableau chromosome[ ]:
	  count = 0;
  for (int k = 0; k < chromsize; k++)
    {
              tmp = oldpop[b].chrom[k];
      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      for (int j = 0; j < stop; j++)
	{
	  if (tmp & mask)
	    {
	      /*fprintf(fp,"1"); */
	      temp1[j + count * UINTSIZE] = 1;
	    }
	  else
	    {
	      /*fprintf(fp,"0"); */
	      temp1[j + count * UINTSIZE] = 0;
	    }
	  tmp = tmp >> 1;
	}
      count++;
    }


 coun = 0;

      for (int k = longeur*largeur- 1; k >= 0; k--)
	{
		chromosome[coun]=temp1[k]; coun++;
	}


// if(b==11){
	// printf("\n------------------- Debut  ----------------------\n");
	    // for(int h=0; h<longeur*largeur; h++)
    // {
        // printf("%d",chromosome[h]);
    // }
// }


 //1)  on verifier si il existe des capteurs supplementaires.

  tab_to_matrix(chromosome);
    couv=couvrage();

// recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        temp[h]=chromosome[h];
    }



    for(int i=0; i<longeur*largeur; i++)
    {
        if(temp[i]==1)
        {

            temp[i]=0;
            tab_to_matrix(temp);
            couv_t=couvrage();


            // ces instructions sont pour la connectivité et la connexité:
			get_position_capteur(temp);
		    connective_connexite (&taux_conn, &connexite);
            // printf("\ntaux_conn=%f  -  connexite=%d ",taux_conn,connexite);
           if(couv_t==couv   && taux_conn==100 && connexite==1)

            {

// recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        chromosome[h]=temp[h];
    }
	i=0;
            }
            else
                // recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        temp[h]=chromosome[h];
    };
        }
    }

	        // for(int i=0; i<longeur*largeur; i++)
            // printf("%d",chromosome[i]);
		// printf("\n");

// if(b==11){
	// printf("\n apre suppression \n");
	    // for(int h=0; h<longeur*largeur; h++)
    // {
        // printf("%d",chromosome[h]);
    // }
// }


    // 2) on deplace les capteurs dans une zone (Rs*Rs) pour trouver un couverture mieux que l'anciene couverture:

    do{
    repeter=0;
    for(int i=0; i<largeur; i++)
    {
        for(int j=0; j<longeur; j++)
        {

// recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        temp[h]=chromosome[h];
    }

	tab_to_matrix(chromosome);
            couv=couvrage();

            if(sensor[i][j]==1)
            {
		// printf("\n(%d,%d)\n",i,j);

                //indices de depart
                if (i - R < 0)
                    k_dep = 0;
                else
                    k_dep = i - R;
                if (j - R < 0)
                    l_dep = 0;
                else
                    l_dep = j - R;
                // indices d'arrive
                if (i + R > largeur - 1)
                {
                    k_stop = largeur - 1;
                }
                else
                    k_stop = i + R;
                if (j + R > longeur - 1)
                    l_stop = longeur - 1;
                else
                    l_stop = j + R;

		// printf("\n %d %d %d %d \n",k_dep,l_dep,k_stop,l_stop);



                //-----------------------------------------//
                //supprimer le noeud:
                sensor[i][j]=0;
                p=get_position(i,j);
                temp[p]=0;
					        // for(int i=0; i<longeur*largeur; i++)
            // printf("%d",temp[i]);
		// printf("\n");


                for(int k=k_dep; k<=k_stop; k++)
                {
                    for(int l=l_dep; l<=l_stop; l++)
                    {
                        sensor[k][l]=1;
                        p=get_position(k,l);
                        temp[p]=1;
	                    tab_to_matrix(temp);  //<<<<<<<<<<
                        couv_t=couvrage();

            // ces instructions sont pour la connectivité et la connexité:
			get_position_capteur(temp);
		    connective_connexite (&taux_conn, &connexite);
            // printf("\ntaux_conn=%f  -  connexite=%d ",taux_conn,connexite);
            if(couv_t>couv   && taux_conn==100 && connexite==1)

                        {

                            // recopier chromosome dans temp:
    for(int h=0; h<longeur*largeur; h++)
    {
        chromosome[h]=temp[h];
    };
                            couv=couv_t;
							//supprimer le noeud pour la nouvelle deploiment:
					    sensor[k][l]=0;
                        p=get_position(k,l);
                        temp[p]=0;

                          repeter=1; // repete puisque il y a un changement dans le deploiment

                           // i=0;
                           // j=0;

						   // if(b==11){
	// printf("\n deplacement couvrage \n");
	    // for(int h=0; h<longeur*largeur; h++)
    // {
        // printf("%d",chromosome[h]);
    // }
// }

                        }
                        else
                        {
                            sensor[k][l]=0;
                            temp[p]=0;
                        }


                    }
                }


            }

        }
    }

}while(repeter==1);


// if(b==11){
// printf("\n");}


 // 3) remplir le chrom par le tableau chromosome:
  int m = longeur*largeur-1;
  for (int k = 0; k < chromsize; k++)
    {
      if (k == (chromsize - 1))
	stop = TotalChromLength - (k * UINTSIZE);
      else
	stop = UINTSIZE;
      valeur = 0;
      for (int j = 0; j < stop; j++)
	{
	  if (chromosome[m] == 1)
	    {
	      valeur = valeur + pow (2, j);
	    }
	  m--;

	}

// if(b==11){
	// printf("%d->%d | ",stop,valeur);
// }

	oldpop[b].chrom[k] = valeur;

    }

// if(b==11){
// printf("\n\apres les amelioration\n");
      // for (int k=0; k<longeur*largeur;k++)
	// {
		// printf("%d",chromosome[k]);
	// }
// }

//////////////////////////////////////////////////////////////////////  affichage ////////////////////////////////
// if(b==11){

	  // count = 0;
  // for (int k = 0; k < chromsize; k++)
    // {
              // tmp = oldpop[b].chrom[k];
      // if (k == (chromsize - 1))
	// stop = TotalChromLength - (k * UINTSIZE);
      // else
	// stop = UINTSIZE;
      // for (int j = 0; j < stop; j++)
	// {
	  // if (tmp & mask)
	    // {
	      // /*fprintf(fp,"1"); */
	      // temp1[j + count * UINTSIZE] = 1;
	    // }
	  // else
	    // {
	      // /*fprintf(fp,"0"); */
	      // temp1[j + count * UINTSIZE] = 0;
	    // }
	  // tmp = tmp >> 1;
	// }
      // count++;
    // }


 // coun = 0;

      // for (int k = longeur*largeur- 1; k >= 0; k--)
	// {
		// chromosome[coun]=temp1[k]; coun++;
	// }

// printf("\n\apres le stockage\n");
      // for (int k=0; k<longeur*largeur;k++)
	// {
		// printf("%d",chromosome[k]);
	// }


// }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////























// 4) calculer fitness 1 et fitness2 ,
      // pour decoder le chromosome à un valeur entier
	  decode_string (&(oldpop[b]));
	  update_x_BIN_ENUM (&(oldpop[b]));

	  objective (&(oldpop[b]));

      MAJ_meilleur_couvr();

      // les statistiques (comme Rank)
            MakeFronts ();
      statistics (oldpop, gen_no);




}







}















objective (person)
     INDIVIDUAL *person;
{
  float a, a1, a2;
  float penalty, g[10];
  int i, nc, num_sensor;

  if (person == NULL)
    error_ptr_null ("person in objective()");

  /* First problem */
#ifdef f1
  printf ("//////////1////////////////");
  a = person->x[0];
  person->fitness[0] = square (a);
  person->fitness[1] = square ((2.0 - a));
  nc = 0;
#endif

  /* Second problem */
#ifdef f2
  printf ("//////////2////////////////");
  a = person->x[0];
  person->fitness[0] =
    (a <= 1.0) ? -a : ((a <= 3) ? -2 + a : ((a <= 4) ? 4 - a : -4 + a));
  person->fitness[1] = (a - 5) * (a - 5);
  nc = 0;
#endif

  /* Third problem */
#ifdef f3
  printf ("//////////3////////////////");
  a1 = person->x[0];
  a2 = person->x[1];
  person->fitness[0] = (a1 - 2) * (a1 - 2) + (a2 - 1) * (a2 - 1) + 2;
  person->fitness[1] = 9 * a1 - (a2 - 1) * (a2 - 1);

  nc = 2;
  g[0] = -1.0 * (a1 * a1 + a2 * a2 - 225.0);
  g[1] = -1.0 * (a1 - 3.0 * a2 + 10.0);
#endif

#ifdef book
  double couvrage_ = 0.0;
  num_sensor = number_of_sensors (person->chrom);
  couvrage_ = couvrage ();


NUM_SENSORS=num_sensor;
COUVRAGE=couvrage_;





  if (couvrage_ == 100 && num_sensor < Min_sensor)
    {
      Min_sensor = num_sensor;
      gen_Min_sensor = gen_no;
    }

  person->fitness[0] = num_sensor;
  person->fitness[1] = couvrage_;
  nc = 0;
  /*
     if(gen_no==max_gen)
     {
     for(int i=0; i< pop_size; i++)
     {
     printf("%f * ",fitness1[i]);
     }
     printf("\n");
     }
   */
#endif

  penalty = 0.0;
  for (i = 0; i < nc; i++)
    if (g[i] < 0.0)
      penalty += PENALTY_COEFF * g[i] * g[i];

  for (i = 0; i < num_obj; i++)
    person->fitness[i] = person->fitness[i] + minmax[i] * penalty;

}

		/********************** END  OF  FILE **************************/

